# 关节约束系统设计文档

## 1. 概述

关节约束是物理引擎中连接两个刚体的机制,通过限制相对运动的自由度来模拟各种机械连接。本文档详细描述五种关节类型的数学原理和实现方案。

---

## 2. 基础理论

### 2.1 约束求解框架

所有关节约束都遵循相同的求解框架:

**约束方程**: C(q) = 0  
**雅可比矩阵**: J = ∂C/∂q  
**约束力**: λ (拉格朗日乘子)

**速度层面约束**:
```
JV + b = 0
```
其中:
- V = [v₁, ω₁, v₂, ω₂]ᵀ (两个刚体的线速度和角速度)
- b = bias项,用于位置误差修正

**有效质量**:
```
K = JM⁻¹Jᵀ
```
其中 M⁻¹ 是广义质量矩阵的逆:
```
M⁻¹ = diag(1/m₁, I₁⁻¹, 1/m₂, I₂⁻¹)
```

**冲量计算**:
```
Δλ = -K⁻¹(JV + b)
V_new = V + M⁻¹JᵀΔλ
```

### 2.2 位置修正 (Baumgarte稳定化)

为防止约束漂移,使用Baumgarte方法:
```
b = β/Δt · C(q)
```
其中 β ∈ [0.1, 0.3] 是稳定化参数。

---

## 3. Fixed Joint (固定关节)

### 3.1 功能描述

完全约束两个刚体的相对位置和旋转,使它们像一个整体。

### 3.2 数学模型

**约束方程**:
```
C_pos = r₂ + R₂·localAnchorB - (r₁ + R₁·localAnchorA) = 0  (3个约束)
C_rot = q₂ - q₁·q_rel = 0                                    (3个约束)
```

**位置约束雅可比**:
```
J_pos = [-I, -(r_A^×), I, (r_B^×)]
```
其中 r_A^× 表示向量的反对称矩阵。

**旋转约束雅可比**:
对于欧拉角或四元数表示,使用:
```
J_rot = [0, -I, 0, I]
```

### 3.3 实现步骤

**关键点**:固定关节需要约束6个自由度(3个平移 + 3个旋转),必须分别处理每个自由度。

```cpp
void SolveFixedJoint(RigidBody& bodyA, RigidBody& bodyB, 
                     const JointComponent& joint, float dt) {
    // 1. 计算世界空间锚点
    Vector3 rA = bodyA.rotation * joint.localAnchorA;
    Vector3 rB = bodyB.rotation * joint.localAnchorB;
    Vector3 worldAnchorA = bodyA.position + rA;
    Vector3 worldAnchorB = bodyB.position + rB;
    
    // 2. 位置约束 - 约束3个方向
    Vector3 C_pos = worldAnchorB - worldAnchorA;
    
    // 为每个方向单独求解(更稳定)
    for (int axis = 0; axis < 3; ++axis) {
        Vector3 direction = Vector3::Zero();
        direction[axis] = 1.0f;
        
        // 约束方程: C = (posB - posA) · direction = 0
        float C = C_pos.dot(direction);
        
        if (std::abs(C) < MathUtils::EPSILON) continue;
        
        // 计算雅可比
        Vector3 rnA = rA.cross(direction);
        Vector3 rnB = rB.cross(direction);
        
        // 有效质量
        float K = bodyA.inverseMass + bodyB.inverseMass
                + rnA.dot(bodyA.I_inv * rnA)
                + rnB.dot(bodyB.I_inv * rnB);
        
        if (K < MathUtils::EPSILON) continue;
        
        // 相对速度
        Vector3 vA = bodyA.velocity + bodyA.angularVelocity.cross(rA);
        Vector3 vB = bodyB.velocity + bodyB.angularVelocity.cross(rB);
        float JV = (vB - vA).dot(direction);
        
        // Baumgarte稳定化
        float bias = (beta / dt) * C;
        
        // 计算冲量
        float lambda = -(JV + bias) / K;
        Vector3 impulse = lambda * direction;
        
        // 应用冲量
        bodyA.velocity -= impulse * bodyA.inverseMass;
        bodyA.angularVelocity -= bodyA.I_inv * rA.cross(impulse);
        bodyB.velocity += impulse * bodyB.inverseMass;
        bodyB.angularVelocity += bodyB.I_inv * rB.cross(impulse);
    }
    
    // 3. 旋转约束 - 约束3个旋转自由度
    Quaternion q_error = bodyB.rotation * bodyA.rotation.conjugate() 
                       * joint.relativeRotation.conjugate();
    Vector3 C_rot = 2.0f * Vector3(q_error.x, q_error.y, q_error.z);
    
    // 为每个旋转轴单独求解
    for (int axis = 0; axis < 3; ++axis) {
        Vector3 rotAxis = Vector3::Zero();
        rotAxis[axis] = 1.0f;
        
        float C = C_rot.dot(rotAxis);
        
        if (std::abs(C) < MathUtils::EPSILON) continue;
        
        // 有效质量
        float K = rotAxis.dot((bodyA.I_inv + bodyB.I_inv) * rotAxis);
        
        if (K < MathUtils::EPSILON) continue;
        
        // 相对角速度
        float JV = (bodyB.angularVelocity - bodyA.angularVelocity).dot(rotAxis);
        
        // Baumgarte稳定化
        float bias = (beta / dt) * C;
        
        // 计算角冲量
        float lambda = -(JV + bias) / K;
        Vector3 angularImpulse = lambda * rotAxis;
        
        // 应用角冲量
        bodyA.angularVelocity -= bodyA.I_inv * angularImpulse;
        bodyB.angularVelocity += bodyB.I_inv * angularImpulse;
    }
}
```

**优化版本**(使用块求解,更高效):

```cpp
void SolveFixedJointBlock(RigidBody& bodyA, RigidBody& bodyB, 
                          const JointComponent& joint, float dt) {
    // 计算世界空间锚点
    Vector3 rA = bodyA.rotation * joint.localAnchorA;
    Vector3 rB = bodyB.rotation * joint.localAnchorB;
    
    // 位置约束 - 3D块求解
    Vector3 C_pos = (bodyB.position + rB) - (bodyA.position + rA);
    
    // 构建3x3有效质量矩阵
    Matrix3 K_pos = Matrix3::Identity() * (bodyA.inverseMass + bodyB.inverseMass);
    Matrix3 rA_cross = CrossMatrix(rA);
    Matrix3 rB_cross = CrossMatrix(rB);
    K_pos += rA_cross * bodyA.I_inv * rA_cross.transpose();
    K_pos += rB_cross * bodyB.I_inv * rB_cross.transpose();
    
    // 相对速度
    Vector3 vA = bodyA.velocity + bodyA.angularVelocity.cross(rA);
    Vector3 vB = bodyB.velocity + bodyB.angularVelocity.cross(rB);
    Vector3 JV_pos = vB - vA;
    
    // 求解
    Vector3 bias = (beta / dt) * C_pos;
    Vector3 lambda_pos = -K_pos.inverse() * (JV_pos + bias);
    
    // 应用位置冲量
    bodyA.velocity -= lambda_pos * bodyA.inverseMass;
    bodyA.angularVelocity -= bodyA.I_inv * rA.cross(lambda_pos);
    bodyB.velocity += lambda_pos * bodyB.inverseMass;
    bodyB.angularVelocity += bodyB.I_inv * rB.cross(lambda_pos);
    
    // 旋转约束 - 3D块求解
    Quaternion q_error = bodyB.rotation * bodyA.rotation.conjugate() 
                       * joint.relativeRotation.conjugate();
    Vector3 C_rot = 2.0f * Vector3(q_error.x, q_error.y, q_error.z);
    
    Matrix3 K_rot = bodyA.I_inv + bodyB.I_inv;
    Vector3 JV_rot = bodyB.angularVelocity - bodyA.angularVelocity;
    
    Vector3 bias_rot = (beta / dt) * C_rot;
    Vector3 lambda_rot = -K_rot.inverse() * (JV_rot + bias_rot);
    
    // 应用旋转冲量
    bodyA.angularVelocity -= bodyA.I_inv * lambda_rot;
    bodyB.angularVelocity += bodyB.I_inv * lambda_rot;
}
```

---

## 4. Hinge Joint (铰链关节)

### 4.1 功能描述

约束两个刚体只能绕一个轴旋转,类似门铰链或机器人关节。

### 4.2 数学模型

**约束方程**:
```
C_point = r₂ + R₂·anchorB - (r₁ + R₁·anchorA) = 0     (3个约束:位置对齐)
C_axis1 = axis₁ · perp₁ = 0                          (1个约束:垂直轴1)
C_axis2 = axis₁ · perp₂ = 0                          (1个约束:垂直轴2)
```
总共5个约束,限制5个自由度,保留绕旋转轴的1个自由度。

**位置约束雅可比** (同Fixed Joint):
```
J_point = [-I, -(r_A^×), I, (r_B^×)]
```

**旋转约束雅可比**:
```
J_axis1 = [0, -perp₁, 0, perp₁]
J_axis2 = [0, -perp₂, 0, perp₂]
```

### 4.3 角度限制

**限制角度范围** [θ_min, θ_max]:

```cpp
float currentAngle = CalculateHingeAngle(bodyA, bodyB, axis);

if (currentAngle < limitMin) {
    // 施加约束力阻止进一步旋转
    float C = currentAngle - limitMin;
    float bias = (beta / dt) * C;
    // 单向约束: λ >= 0
} else if (currentAngle > limitMax) {
    float C = currentAngle - limitMax;
    float bias = (beta / dt) * C;
    // 单向约束: λ <= 0
}
```

**角度计算**:
```cpp
float CalculateHingeAngle(const RigidBody& bodyA, const RigidBody& bodyB,
                          const Vector3& axis) {
    Vector3 ref = ChoosePerpendicular(axis);
    Vector3 refA = bodyA.rotation * ref;
    Vector3 refB = bodyB.rotation * ref;
    
    // 投影到垂直于axis的平面
    refA -= axis * axis.dot(refA);
    refB -= axis * axis.dot(refB);
    refA.normalize();
    refB.normalize();
    
    float cosAngle = refA.dot(refB);
    float sinAngle = axis.dot(refA.cross(refB));
    return atan2(sinAngle, cosAngle);
}
```

### 4.4 马达实现

**目标角速度** ω_target:

```cpp
if (useMotor) {
    float currentAngularSpeed = axis.dot(bodyB.angularVelocity 
                                        - bodyA.angularVelocity);
    float speedError = motorSpeed - currentAngularSpeed;
    
    // PD控制器
    float desiredTorque = kp * speedError;
    desiredTorque = Clamp(desiredTorque, -motorForce, motorForce);
    
    // 应用扭矩
    bodyA.angularVelocity -= (bodyA.I_inv * axis) * desiredTorque;
    bodyB.angularVelocity += (bodyB.I_inv * axis) * desiredTorque;
}
```

### 4.5 完整实现

```cpp
void SolveHingeJoint(RigidBody& bodyA, RigidBody& bodyB,
                     const JointComponent& joint) {
    Vector3 axis = bodyA.rotation * joint.data.hinge.axis;
    axis.normalize();
    
    // 1. 位置约束 (同Fixed Joint的位置部分)
    SolvePointConstraint(bodyA, bodyB, joint);
    
    // 2. 旋转约束
    Vector3 perp1, perp2;
    BuildOrthonormalBasis(axis, perp1, perp2);
    
    // 约束perpendicular方向的旋转
    for (const Vector3& perp : {perp1, perp2}) {
        Vector3 C_rot = bodyA.rotation.rotate(perp) 
                      - bodyB.rotation.rotate(perp);
        float bias = (beta / dt) * C_rot.length();
        
        Matrix3 K = bodyA.I_inv + bodyB.I_inv;
        Vector3 JV = (bodyB.angularVelocity - bodyA.angularVelocity);
        float lambda = -(perp.dot(K.inverse() * (JV + bias * perp)));
        
        bodyA.angularVelocity -= bodyA.I_inv * (perp * lambda);
        bodyB.angularVelocity += bodyB.I_inv * (perp * lambda);
    }
    
    // 3. 角度限制
    if (joint.hasLimits) {
        float angle = CalculateHingeAngle(bodyA, bodyB, axis);
        // 应用限制约束...
    }
    
    // 4. 马达
    if (joint.data.hinge.useMotor) {
        // 应用马达扭矩...
    }
}
```

---

## 5. Distance Joint (距离关节)

### 5.1 功能描述

维持两个锚点之间的固定距离,像一根刚性杆。

### 5.2 数学模型

**约束方程**:
```
C = |r₂ + R₂·anchorB - (r₁ + R₁·anchorA)| - distance = 0
```

**方向向量**:
```
n = (worldAnchorB - worldAnchorA).normalized()
```

**雅可比矩阵**:
```
J = [-n, -(r_A × n), n, (r_B × n)]
```

**有效质量**:
```
K = 1/m₁ + 1/m₂ + n·((r_A^×)I₁⁻¹(r_A^×)n) + n·((r_B^×)I₂⁻¹(r_B^×)n)
```

### 5.3 实现步骤

```cpp
void SolveDistanceJoint(RigidBody& bodyA, RigidBody& bodyB,
                        const JointComponent& joint) {
    // 1. 计算世界空间位置
    Vector3 rA = bodyA.rotation * joint.localAnchorA;
    Vector3 rB = bodyB.rotation * joint.localAnchorB;
    Vector3 worldAnchorA = bodyA.position + rA;
    Vector3 worldAnchorB = bodyB.position + rB;
    
    // 2. 计算当前距离和方向
    Vector3 delta = worldAnchorB - worldAnchorA;
    float currentDistance = delta.length();
    
    if (currentDistance < 1e-6f) return; // 避免除零
    
    Vector3 n = delta / currentDistance;
    
    // 3. 约束方程
    float targetDistance = joint.data.distance.restLength;
    float C = currentDistance - targetDistance;
    float bias = (beta / dt) * C;
    
    // 4. 计算相对速度
    Vector3 vA = bodyA.velocity + bodyA.angularVelocity.cross(rA);
    Vector3 vB = bodyB.velocity + bodyB.angularVelocity.cross(rB);
    float JV = n.dot(vB - vA);
    
    // 5. 计算有效质量
    float K = 1.0f / bodyA.mass + 1.0f / bodyB.mass;
    K += n.dot(rA.cross(bodyA.I_inv * rA.cross(n)));
    K += n.dot(rB.cross(bodyB.I_inv * rB.cross(n)));
    
    // 6. 计算冲量
    float lambda = -(JV + bias) / K;
    
    // 7. 应用冲量
    Vector3 impulse = lambda * n;
    bodyA.velocity -= impulse / bodyA.mass;
    bodyA.angularVelocity -= bodyA.I_inv * rA.cross(impulse);
    bodyB.velocity += impulse / bodyB.mass;
    bodyB.angularVelocity += bodyB.I_inv * rB.cross(impulse);
}
```

### 5.4 距离范围约束

如果允许距离在一个范围内变化:

```cpp
float minDist = joint.data.distance.minDistance;
float maxDist = joint.data.distance.maxDistance;

if (currentDistance < minDist) {
    // 施加推开的力
    float C = currentDistance - minDist;
    // λ >= 0 (单向约束)
} else if (currentDistance > maxDist) {
    // 施加拉近的力
    float C = currentDistance - maxDist;
    // λ <= 0 (单向约束)
} else {
    // 在范围内,不施加约束
    return;
}
```

---

## 6. Spring Joint (弹簧关节)

### 6.1 功能描述

模拟弹簧-阻尼器系统,使用胡克定律和阻尼力。

### 6.2 数学模型

**弹簧力**:
```
F_spring = -k(l - l₀)n
```
其中:
- k: 刚度系数 (N/m)
- l: 当前长度
- l₀: 静止长度
- n: 方向向量

**阻尼力**:
```
F_damping = -c·v_rel·n
```
其中:
- c: 阻尼系数 (N·s/m)
- v_rel: 相对速度在方向n上的投影

**总力**:
```
F_total = F_spring + F_damping
```

### 6.3 实现方式

**方法1: 显式力施加** (简单但可能不稳定)

```cpp
void ApplySpringForce(RigidBody& bodyA, RigidBody& bodyB,
                      const JointComponent& joint, float dt) {
    // 1. 计算位置和方向
    Vector3 worldAnchorA = bodyA.position + bodyA.rotation * joint.localAnchorA;
    Vector3 worldAnchorB = bodyB.position + bodyB.rotation * joint.localAnchorB;
    Vector3 delta = worldAnchorB - worldAnchorA;
    float length = delta.length();
    
    if (length < 1e-6f) return;
    
    Vector3 n = delta / length;
    
    // 2. 弹簧力
    float displacement = length - joint.data.spring.restLength;
    float springForce = joint.data.spring.stiffness * displacement;
    
    // 3. 阻尼力
    Vector3 vA = bodyA.velocity + bodyA.angularVelocity.cross(rA);
    Vector3 vB = bodyB.velocity + bodyB.angularVelocity.cross(rB);
    float relativeVelocity = n.dot(vB - vA);
    float dampingForce = joint.data.spring.damping * relativeVelocity;
    
    // 4. 总力
    Vector3 force = (springForce + dampingForce) * n;
    
    // 5. 应用力
    bodyA.applyForceAtPoint(force, worldAnchorA);
    bodyB.applyForceAtPoint(-force, worldAnchorB);
}
```

**方法2: 软约束** (更稳定,推荐)

使用柔性约束框架:

```cpp
void SolveSpringConstraint(RigidBody& bodyA, RigidBody& bodyB,
                          const JointComponent& joint, float dt) {
    // 计算几何量 (同上)
    Vector3 rA = bodyA.rotation * joint.localAnchorA;
    Vector3 rB = bodyB.rotation * joint.localAnchorB;
    Vector3 delta = (bodyB.position + rB) - (bodyA.position + rA);
    float length = delta.length();
    Vector3 n = delta / length;
    
    // 软约束参数
    float k = joint.data.spring.stiffness;
    float c = joint.data.spring.damping;
    float C = length - joint.data.spring.restLength;
    
    // 相对速度
    Vector3 vA = bodyA.velocity + bodyA.angularVelocity.cross(rA);
    Vector3 vB = bodyB.velocity + bodyB.angularVelocity.cross(rB);
    float JV = n.dot(vB - vA);
    
    // 有效质量
    float K_constraint = 1.0f / bodyA.mass + 1.0f / bodyB.mass;
    K_constraint += n.dot(rA.cross(bodyA.I_inv * rA.cross(n)));
    K_constraint += n.dot(rB.cross(bodyB.I_inv * rB.cross(n)));
    
    // 软约束公式
    float gamma = 1.0f / (dt * (c + dt * k));
    float beta_soft = dt * k * gamma;
    
    float effectiveMass = K_constraint + gamma;
    float bias = beta_soft * C + gamma * JV;
    
    float lambda = -bias / effectiveMass;
    
    // 应用冲量
    Vector3 impulse = lambda * n;
    bodyA.velocity -= impulse / bodyA.mass;
    bodyA.angularVelocity -= bodyA.I_inv * rA.cross(impulse);
    bodyB.velocity += impulse / bodyB.mass;
    bodyB.angularVelocity += bodyB.I_inv * rB.cross(impulse);
}
```

### 6.4 参数调整指南

**刚度 (Stiffness)**:
- 低刚度 (1-100): 柔软的弹簧
- 中刚度 (100-1000): 普通弹簧
- 高刚度 (1000+): 接近刚性约束

**阻尼 (Damping)**:
- 临界阻尼: c_critical = 2√(k·m)
- 欠阻尼: c < c_critical (振荡)
- 过阻尼: c > c_critical (缓慢恢复)

---

## 7. Slider Joint (滑动关节)

### 7.1 功能描述

约束两个刚体只能沿一个轴平移,类似活塞。

### 7.2 数学模型

**约束方程**:
```
C_perp = (delta - (delta·axis)axis) = 0    (2个约束:垂直位移)
C_rot1 = axis₁ · perp₁ = 0                 (2个约束:旋转对齐)
C_rot2 = axis₁ · perp₂ = 0
```

**平移限制**:
```
d = delta · axis
if d < minDistance: C_limit = d - minDistance
if d > maxDistance: C_limit = d - maxDistance
```

### 7.3 实现步骤

```cpp
void SolveSliderJoint(RigidBody& bodyA, RigidBody& bodyB,
                     const JointComponent& joint) {
    Vector3 axis = bodyA.rotation * joint.data.slider.axis;
    axis.normalize();
    
    // 1. 位置约束 - 垂直于轴的方向
    Vector3 delta = bodyB.position - bodyA.position;
    float alongAxis = delta.dot(axis);
    Vector3 perpDelta = delta - alongAxis * axis;
    
    if (perpDelta.lengthSquared() > 1e-6f) {
        Vector3 n = perpDelta.normalized();
        // 求解垂直位移约束...
    }
    
    // 2. 旋转约束 (保持轴平行)
    Vector3 axisB = bodyB.rotation * joint.data.slider.axis;
    Vector3 axisError = axis.cross(axisB);
    // 求解旋转约束...
    
    // 3. 平移限制
    if (joint.hasLimits) {
        if (alongAxis < joint.data.slider.minDistance) {
            // 单向约束...
        } else if (alongAxis > joint.data.slider.maxDistance) {
            // 单向约束...
        }
    }
}
```

---

## 8. 关节断裂

### 8.1 断裂条件

监控施加在关节上的力和扭矩:

```cpp
struct JointForces {
    Vector3 linearForce;
    Vector3 torque;
    
    float GetMagnitude() const {
        return linearForce.length();
    }
    
    float GetTorqueMagnitude() const {
        return torque.length();
    }
};
```

### 8.2 力的累积

在约束求解过程中累积冲量:

```cpp
// 在每次迭代中
accumulatedImpulse += lambda;

// 迭代结束后转换为力
jointForces.linearForce = accumulatedImpulse / dt;
```

### 8.3 断裂检测

```cpp
bool CheckJointBreakage(const JointComponent& joint, 
                       const JointForces& forces) {
    if (forces.GetMagnitude() > joint.breakForce) {
        return true;
    }
    
    if (forces.GetTorqueMagnitude() > joint.breakTorque) {
        return true;
    }
    
    return false;
}

void UpdateJoints(EntityManager& entities, float dt) {
    for (auto [entity, joint, bodyA, bodyB] : GetJoints()) {
        JointForces forces = SolveJoint(bodyA, bodyB, joint);
        
        if (CheckJointBreakage(joint, forces)) {
            entities.RemoveComponent<JointComponent>(entity);
            // 可选: 触发断裂事件,播放音效等
            OnJointBroken(entity, forces);
        }
    }
}
```

---

## 9. 实现建议

### 9.1 求解顺序

```cpp
void PhysicsSystem::SolveConstraints(float dt) {
    // 1. 接触约束 (高优先级)
    for (int i = 0; i < contactIterations; ++i) {
        SolveContactConstraints(dt);
    }
    
    // 2. 关节约束
    for (int i = 0; i < jointIterations; ++i) {
        for (auto& joint : joints) {
            switch (joint.type) {
                case Fixed: SolveFixedJoint(joint, dt); break;
                case Hinge: SolveHingeJoint(joint, dt); break;
                case Distance: SolveDistanceJoint(joint, dt); break;
                case Spring: SolveSpringJoint(joint, dt); break;
                case Slider: SolveSliderJoint(joint, dt); break;
            }
        }
    }
}
```

### 9.2 迭代次数建议

- **接触约束**: 8-12次
- **关节约束**: 4-8次
- 固定关节可能需要更多迭代以保持稳定

### 9.3 数值稳定性

1. **暖启动**: 保存上一帧的λ值作为初始猜测
2. **冲量限制**: 限制单次迭代的最大冲量
3. **休眠机制**: 对几乎静止的关节跳过求解

### 9.4 调试工具

```cpp
void DebugDrawJoint(const JointComponent& joint, 
                   const RigidBody& bodyA,
                   const RigidBody& bodyB) {
    Vector3 anchorA = bodyA.position + bodyA.rotation * joint.localAnchorA;
    Vector3 anchorB = bodyB.position + bodyB.rotation * joint.localAnchorB;
    
    DrawLine(anchorA, anchorB, Color::Green);
    DrawSphere(anchorA, 0.1f, Color::Red);
    DrawSphere(anchorB, 0.1f, Color::Blue);
    
    if (joint.type == Hinge) {
        Vector3 axis = bodyA.rotation * joint.data.hinge.axis;
        DrawArrow(anchorA, anchorA + axis * 0.5f, Color::Yellow);
    }
}
```

---

## 10. 测试验证

### 10.1 Fixed Joint 测试

- 两个立方体固定连接,施加外力不应分离
- 旋转一个立方体,另一个应同步旋转

### 10.2 Hinge Joint 测试

- 创建链条结构,验证只能绕轴旋转
- 测试角度限制,达到限制时应停止
- 测试马达,应产生匀速旋转

### 10.3 Distance Joint 测试

- 两个小球保持固定距离
- 施加力时距离不变但可自由旋转

### 10.4 Spring Joint 测试

- 拉伸后应产生振荡并逐渐稳定
- 阻尼过大时应无振荡

### 10.5 断裂测试

- 施加超过阈值的力,关节应断开
- 断开后刚体应自由运动

---

## 11. 性能优化

### 11.1 缓存计算

```cpp
struct JointCache {
    Matrix3 effectiveMass;
    Vector3 rA, rB;
    Vector3 bias;
    float accumulatedImpulse;
};
```

### 11.2 批处理

对相同类型的关节批量处理,提高缓存命中率。

### 11.3 空间分区

使用空间哈希或BVH加速关节查询。

---

## 12. 参考资料

- **Erin Catto**: "Iterative Dynamics with Temporal Coherence" (GDC 2005)
- **Box2D源码**: 2D关节实现参考
- **Bullet Physics**: 3D关节实现参考
- **Game Physics Pearls**: 高级约束技术

---

## 附录: 常用数学工具

请查阅项目中的transform实现和mathutils