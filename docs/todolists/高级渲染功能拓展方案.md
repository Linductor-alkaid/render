# RenderEngine é«˜çº§æ¸²æŸ“åŠŸèƒ½æ‰©å±•æ–¹æ¡ˆ

## 1. é¡¹ç›®ç°çŠ¶åˆ†æ

### 1.1 å½“å‰æ¶æ„ä¼˜åŠ¿
- âœ… å®Œæ•´çš„ECSæ¶æ„ï¼Œä¾¿äºæ·»åŠ æ–°çš„æ¸²æŸ“ç»„ä»¶å’Œç³»ç»Ÿ
- âœ… æ¨¡å—åŒ–è®¾è®¡ï¼Œæ”¯æŒæ’ä»¶å¼åŠŸèƒ½æ‰©å±•
- âœ… LODç³»ç»Ÿå·²ç»å®Œå–„ï¼Œä¸ºæ€§èƒ½ä¼˜åŒ–æ‰“ä¸‹åŸºç¡€
- âœ… æ‰¹å¤„ç†ç³»ç»Ÿæ”¯æŒå¤šç§æ¸²æŸ“ç­–ç•¥
- âœ… èµ„æºç®¡ç†ç³»ç»Ÿæ”¯æŒå¼‚æ­¥åŠ è½½

### 1.2 å¯æ‰©å±•çš„é«˜çº§æ¸²æŸ“æ–¹å‘
åŸºäºç°æœ‰æ¶æ„ï¼Œå»ºè®®æŒ‰ä»¥ä¸‹ä¼˜å…ˆçº§æ‰©å±•ï¼š

1. **åŸºäºç‰©ç†çš„æ¸²æŸ“ (PBR)** - æå‡è§†è§‰çœŸå®æ„Ÿ
2. **å»¶è¿Ÿæ¸²æŸ“ç®¡çº¿** - æ”¯æŒå¤§é‡åŠ¨æ€å…‰æº
3. **é˜´å½±ç³»ç»Ÿå¢å¼º** - çº§è”é˜´å½±è´´å›¾ã€è½¯é˜´å½±
4. **åå¤„ç†æ•ˆæœ** - Bloomã€è‰²è°ƒæ˜ å°„ã€æŠ—é”¯é½¿
5. **å…¨å±€å…‰ç…§** - ç¯å¢ƒå…‰é®è”½ã€å±å¹•ç©ºé—´åå°„
6. **ä½“ç§¯æ•ˆæœ** - ä½“ç§¯å…‰ã€ä½“ç§¯é›¾
7. **é«˜çº§ç²’å­ç³»ç»Ÿ** - GPUç²’å­ã€ç‰©ç†æ¨¡æ‹Ÿ
8. **åœ°å½¢æ¸²æŸ“ç³»ç»Ÿ** - é«˜åº¦å›¾ã€å¤šå±‚çº¹ç†ã€ç»†åˆ†

---

## 2. é«˜çº§æ¸²æŸ“åŠŸèƒ½è¯¦ç»†è®¾è®¡

### 2.1 åŸºäºç‰©ç†çš„æ¸²æŸ“ (PBR) ç³»ç»Ÿ

#### 2.1.1 æ¶æ„è®¾è®¡

```mermaid
graph TB
    subgraph "PBR Material System"
        PBRMaterial[PBRæè´¨] --> MetallicWorkflow[é‡‘å±åº¦å·¥ä½œæµ]
        PBRMaterial --> SpecularWorkflow[é«˜å…‰å·¥ä½œæµ]
        
        MetallicWorkflow --> BaseColor[åŸºç¡€è‰²è´´å›¾]
        MetallicWorkflow --> Metallic[é‡‘å±åº¦è´´å›¾]
        MetallicWorkflow --> Roughness[ç²—ç³™åº¦è´´å›¾]
        MetallicWorkflow --> Normal[æ³•çº¿è´´å›¾]
        MetallicWorkflow --> AO[AOè´´å›¾]
        MetallicWorkflow --> Emissive[è‡ªå‘å…‰è´´å›¾]
        
        SpecularWorkflow --> Diffuse[æ¼«åå°„è´´å›¾]
        SpecularWorkflow --> Specular[é«˜å…‰è´´å›¾]
        SpecularWorkflow --> Glossiness[å…‰æ³½åº¦è´´å›¾]
    end
    
    subgraph "PBR Lighting"
        IBL[åŸºäºå›¾åƒçš„å…‰ç…§] --> DiffuseIBL[æ¼«åå°„IBL]
        IBL --> SpecularIBL[é•œé¢åå°„IBL]
        
        DiffuseIBL --> IrradianceMap[è¾ç…§åº¦å›¾]
        SpecularIBL --> PrefilteredMap[é¢„è¿‡æ»¤ç¯å¢ƒå›¾]
        SpecularIBL --> BRDFLookup[BRDFæŸ¥æ‰¾è¡¨]
    end
    
    subgraph "PBR Shader"
        PBRShader[PBRç€è‰²å™¨] --> CookTorranceBRDF[Cook-Torrance BRDF]
        CookTorranceBRDF --> DistributionGGX[GGXåˆ†å¸ƒ]
        CookTorranceBRDF --> GeometrySchlick[Schlickå‡ ä½•å‡½æ•°]
        CookTorranceBRDF --> FresnelSchlick[Schlickè²æ¶…å°”]
    end
    
    PBRMaterial --> PBRShader
    IBL --> PBRShader
    
    style PBRMaterial fill:#e1f5fe
    style IBL fill:#fff3e0
    style PBRShader fill:#f3e5f5
```

#### 2.1.2 æ ¸å¿ƒç»„ä»¶

**PBRMaterial ç±»**
```cpp
class PBRMaterial : public Material {
public:
    enum class Workflow {
        MetallicRoughness,  // é‡‘å±åº¦/ç²—ç³™åº¦å·¥ä½œæµ
        SpecularGlossiness  // é«˜å…‰/å…‰æ³½åº¦å·¥ä½œæµ
    };
    
    struct Parameters {
        // é‡‘å±åº¦å·¥ä½œæµ
        glm::vec3 albedo = glm::vec3(1.0f);
        float metallic = 0.0f;
        float roughness = 0.5f;
        float ao = 1.0f;
        
        // é€šç”¨å‚æ•°
        glm::vec3 emissive = glm::vec3(0.0f);
        float emissiveStrength = 1.0f;
        float normalStrength = 1.0f;
        
        // çº¹ç†
        std::shared_ptr<Texture> albedoMap;
        std::shared_ptr<Texture> metallicMap;
        std::shared_ptr<Texture> roughnessMap;
        std::shared_ptr<Texture> normalMap;
        std::shared_ptr<Texture> aoMap;
        std::shared_ptr<Texture> emissiveMap;
    };
    
private:
    Workflow workflow_;
    Parameters params_;
};
```

**IBL (Image-Based Lighting) ç³»ç»Ÿ**
```cpp
class IBLEnvironment {
public:
    void loadHDRI(const std::string& hdriPath);
    void generateIrradianceMap();
    void generatePrefilteredMap();
    void generateBRDFLookup();
    
    std::shared_ptr<TextureCubemap> getIrradianceMap() const;
    std::shared_ptr<TextureCubemap> getPrefilteredMap() const;
    std::shared_ptr<Texture2D> getBRDFLookup() const;
    
private:
    std::shared_ptr<TextureCubemap> hdriCubemap_;
    std::shared_ptr<TextureCubemap> irradianceMap_;
    std::shared_ptr<TextureCubemap> prefilteredMap_;
    std::shared_ptr<Texture2D> brdfLookup_;
};
```

#### 2.1.3 å®ç°æ­¥éª¤

**é˜¶æ®µ1: åŸºç¡€PBRæè´¨ç³»ç»Ÿ (1-2å‘¨)**
1. å®ç° `PBRMaterial` ç±»
2. åˆ›å»ºPBRç€è‰²å™¨ï¼ˆCook-Torrance BRDFï¼‰
3. æ”¯æŒåŸºç¡€çº¹ç†è¾“å…¥ï¼ˆalbedo, metallic, roughness, normal, aoï¼‰
4. é›†æˆåˆ°ç°æœ‰çš„æ¸²æŸ“ç®¡çº¿

**é˜¶æ®µ2: IBLç³»ç»Ÿ (2-3å‘¨)**
1. å®ç°HDRIåŠ è½½å’Œç«‹æ–¹ä½“è´´å›¾è½¬æ¢
2. ç”Ÿæˆè¾ç…§åº¦å›¾ï¼ˆå·ç§¯è®¡ç®—ï¼‰
3. ç”Ÿæˆé¢„è¿‡æ»¤ç¯å¢ƒå›¾ï¼ˆé‡è¦æ€§é‡‡æ ·ï¼‰
4. ç”ŸæˆBRDFæŸ¥æ‰¾è¡¨
5. ç€è‰²å™¨é›†æˆIBLè®¡ç®—

**é˜¶æ®µ3: é«˜çº§ç‰¹æ€§ (1-2å‘¨)**
1. æ”¯æŒè‡ªå‘å…‰æè´¨
2. æ¸…æ¼†å±‚ï¼ˆClear Coatï¼‰æ•ˆæœ
3. æ¬¡è¡¨é¢æ•£å°„ï¼ˆSubsurface Scatteringï¼‰è¿‘ä¼¼
4. å„å‘å¼‚æ€§åå°„ï¼ˆAnisotropic Reflectionï¼‰

---

### 2.2 å»¶è¿Ÿæ¸²æŸ“ç®¡çº¿ (Deferred Rendering)

#### 2.2.1 æ¶æ„è®¾è®¡

```mermaid
graph TB
    subgraph "Deferred Rendering Pipeline"
        GeometryPass[å‡ ä½•é€šé“] --> GBuffer[G-Buffer]
        
        GBuffer --> Position[ä½ç½®ç¼“å†²]
        GBuffer --> Normal[æ³•çº¿ç¼“å†²]
        GBuffer --> Albedo[åç…§ç‡ç¼“å†²]
        GBuffer --> MetallicRoughness[é‡‘å±åº¦ç²—ç³™åº¦ç¼“å†²]
        GBuffer --> Emissive[è‡ªå‘å…‰ç¼“å†²]
        
        GBuffer --> LightingPass[å…‰ç…§é€šé“]
        LightingPass --> DirectLighting[ç›´æ¥å…‰ç…§]
        LightingPass --> IndirectLighting[é—´æ¥å…‰ç…§]
        
        DirectLighting --> TiledLighting[åˆ†å—å…‰ç…§]
        DirectLighting --> ClusteredLighting[èšç°‡å…‰ç…§]
        
        LightingPass --> LightAccumulation[å…‰ç…§ç´¯ç§¯ç¼“å†²]
        LightAccumulation --> TransparentPass[é€æ˜ç‰©ä½“é€šé“]
        TransparentPass --> PostProcessing[åå¤„ç†]
    end
    
    subgraph "Light Culling"
        LightGrid[å…‰æºç½‘æ ¼] --> TileFrustum[Tileè§†é”¥]
        LightGrid --> ClusterAABB[Cluster AABB]
        TileFrustum --> LightList[å…‰æºåˆ—è¡¨]
        ClusterAABB --> LightList
    end
    
    TiledLighting --> LightGrid
    ClusteredLighting --> LightGrid
    
    style GeometryPass fill:#e1f5fe
    style LightingPass fill:#fff3e0
    style LightGrid fill:#f3e5f5
```

#### 2.2.2 æ ¸å¿ƒç»„ä»¶

**GBuffer é…ç½®**
```cpp
class GBuffer {
public:
    enum class Layout {
        Standard,      // æ ‡å‡†å¸ƒå±€
        Optimized,     // ä¼˜åŒ–å¸ƒå±€ï¼ˆå‹ç¼©æ³•çº¿ã€æ‰“åŒ…æ•°æ®ï¼‰
        Thin          // è–„G-Bufferï¼ˆä»…ä½ç½®+æ³•çº¿ï¼‰
    };
    
    struct Attachments {
        std::shared_ptr<Texture2D> position;       // RGB: ä¸–ç•Œç©ºé—´ä½ç½®
        std::shared_ptr<Texture2D> normal;         // RGB: ä¸–ç•Œç©ºé—´æ³•çº¿
        std::shared_ptr<Texture2D> albedo;         // RGB: åç…§ç‡, A: AO
        std::shared_ptr<Texture2D> metallicRoughness; // R: é‡‘å±åº¦, G: ç²—ç³™åº¦
        std::shared_ptr<Texture2D> emissive;       // RGB: è‡ªå‘å…‰
        std::shared_ptr<Texture2D> depth;          // Depth buffer
    };
    
    void create(uint32_t width, uint32_t height, Layout layout);
    void bind();
    void clear();
    const Attachments& getAttachments() const;
    
private:
    Layout layout_;
    Attachments attachments_;
    uint32_t fbo_;
};
```

**åˆ†å—å…‰ç…§ï¼ˆTiled Lightingï¼‰**
```cpp
class TiledLightingSystem {
public:
    struct Config {
        uint32_t tileSize = 16;  // æ¯ä¸ªtileçš„åƒç´ å¤§å°
        uint32_t maxLightsPerTile = 256;
    };
    
    void initialize(uint32_t screenWidth, uint32_t screenHeight, const Config& config);
    void cullLights(const std::vector<Light*>& lights, const Camera& camera);
    void render(const GBuffer& gbuffer);
    
private:
    void buildTileFrustums();
    void assignLightsToTiles(const std::vector<Light*>& lights);
    
    Config config_;
    std::vector<Frustum> tileFrustums_;
    std::shared_ptr<ComputeShader> lightCullingShader_;
    std::shared_ptr<StorageBuffer> lightListSSBO_;
    std::shared_ptr<StorageBuffer> lightGridSSBO_;
};
```

**èšç°‡å…‰ç…§ï¼ˆClustered Lightingï¼‰**
```cpp
class ClusteredLightingSystem {
public:
    struct Config {
        uint32_t clusterGridX = 16;
        uint32_t clusterGridY = 9;
        uint32_t clusterGridZ = 24;
        float nearPlane = 0.1f;
        float farPlane = 1000.0f;
        uint32_t maxLightsPerCluster = 128;
    };
    
    void initialize(const Config& config);
    void update(const Camera& camera);
    void cullLights(const std::vector<Light*>& lights);
    void render(const GBuffer& gbuffer);
    
private:
    void buildClusterGrid();
    void computeClusterAABBs(const Camera& camera);
    void assignLightsToCluster(const std::vector<Light*>& lights);
    
    Config config_;
    std::vector<AABB> clusterAABBs_;
    std::shared_ptr<ComputeShader> clusterBuildShader_;
    std::shared_ptr<ComputeShader> lightAssignShader_;
    std::shared_ptr<StorageBuffer> clusterSSBO_;
    std::shared_ptr<StorageBuffer> lightIndicesSSBO_;
};
```

#### 2.2.3 å®ç°æ­¥éª¤

**é˜¶æ®µ1: åŸºç¡€å»¶è¿Ÿæ¸²æŸ“ (2-3å‘¨)**
1. å®ç°GBufferç³»ç»Ÿ
2. å‡ ä½•é€šé“æ¸²æŸ“
3. åŸºç¡€å…‰ç…§é€šé“ï¼ˆæ”¯æŒç‚¹å…‰æºã€æ–¹å‘å…‰ï¼‰
4. é€æ˜ç‰©ä½“å‰å‘æ¸²æŸ“å›é€€

**é˜¶æ®µ2: åˆ†å—å…‰ç…§ (2å‘¨)**
1. å®ç°Tileåˆ’åˆ†
2. å…‰æºå‰”é™¤è®¡ç®—ç€è‰²å™¨
3. å…‰ç…§è®¡ç®—ä¼˜åŒ–

**é˜¶æ®µ3: èšç°‡å…‰ç…§ (2-3å‘¨)**
1. 3Dèšç°‡ç½‘æ ¼æ„å»º
2. æ·±åº¦åˆ†ç‰‡ç­–ç•¥ï¼ˆå¯¹æ•°/çº¿æ€§ï¼‰
3. å…‰æºåˆ†é…è®¡ç®—ç€è‰²å™¨
4. æ€§èƒ½ä¼˜åŒ–å’Œè°ƒè¯•å·¥å…·

---

### 2.3 é«˜çº§é˜´å½±ç³»ç»Ÿ

#### 2.3.1 æ¶æ„è®¾è®¡

```mermaid
graph TB
    subgraph "Shadow System"
        ShadowManager[é˜´å½±ç®¡ç†å™¨] --> ShadowMapAtlas[é˜´å½±è´´å›¾å›¾é›†]
        ShadowManager --> CSM[çº§è”é˜´å½±è´´å›¾]
        ShadowManager --> VSM[æ–¹å·®é˜´å½±è´´å›¾]
        ShadowManager --> PCF[PCFè½¯é˜´å½±]
        
        CSM --> CascadeSplits[çº§è”åˆ†å‰²]
        CSM --> CascadeTransition[çº§è”è¿‡æ¸¡]
        
        VSM --> GaussianBlur[é«˜æ–¯æ¨¡ç³Š]
        
        PCF --> PoissonDisk[æ³Šæ¾é‡‡æ ·]
        PCF --> PCSSoftness[è½¯é˜´å½±æ§åˆ¶]
    end
    
    subgraph "Light Types"
        DirectionalShadow[æ–¹å‘å…‰é˜´å½±] --> CSM
        PointShadow[ç‚¹å…‰æºé˜´å½±] --> CubeShadowMap[ç«‹æ–¹ä½“é˜´å½±è´´å›¾]
        SpotShadow[èšå…‰ç¯é˜´å½±] --> PerspectiveShadowMap[é€è§†é˜´å½±è´´å›¾]
    end
    
    style ShadowManager fill:#e1f5fe
    style CSM fill:#fff3e0
    style DirectionalShadow fill:#f3e5f5
```

#### 2.3.2 æ ¸å¿ƒç»„ä»¶

**çº§è”é˜´å½±è´´å›¾ï¼ˆCSMï¼‰**
```cpp
class CascadedShadowMap {
public:
    struct Config {
        uint32_t cascadeCount = 4;
        uint32_t resolution = 2048;
        std::vector<float> cascadeSplits = {0.1f, 0.25f, 0.5f, 1.0f};
        float splitLambda = 0.5f;  // å¯¹æ•°/çº¿æ€§æ··åˆ
        float cascadeBlendDistance = 0.1f;
    };
    
    void initialize(const Config& config);
    void update(const Camera& camera, const DirectionalLight& light);
    void render(const std::vector<Renderable*>& renderables);
    
    const std::vector<glm::mat4>& getLightMatrices() const;
    const std::vector<float>& getCascadeDistances() const;
    std::shared_ptr<Texture2DArray> getShadowMapArray() const;
    
private:
    void computeCascadeSplits(const Camera& camera);
    void computeLightViewProj(const Camera& camera, uint32_t cascadeIndex);
    void optimizeFrustumFit(uint32_t cascadeIndex);
    
    Config config_;
    std::vector<glm::mat4> lightMatrices_;
    std::vector<float> cascadeDistances_;
    std::vector<Frustum> cascadeFrustums_;
    std::shared_ptr<Texture2DArray> shadowMapArray_;
    std::vector<uint32_t> fboArray_;
};
```

**è½¯é˜´å½±ï¼ˆPCFï¼‰**
```cpp
class SoftShadowRenderer {
public:
    enum class FilterMode {
        PCF,          // Percentage Closer Filtering
        PCSS,         // Percentage Closer Soft Shadows
        VSM,          // Variance Shadow Maps
        ESM           // Exponential Shadow Maps
    };
    
    struct Config {
        FilterMode filterMode = FilterMode::PCF;
        uint32_t sampleCount = 16;
        float filterSize = 2.0f;
        float lightSize = 0.1f;  // For PCSS
    };
    
    void setConfig(const Config& config);
    void generatePoissonDisk(uint32_t sampleCount);
    
    // åœ¨ç€è‰²å™¨ä¸­ä½¿ç”¨
    std::string generateShaderCode() const;
    
private:
    Config config_;
    std::vector<glm::vec2> poissonDisk_;
};
```

#### 2.3.3 å®ç°æ­¥éª¤

**é˜¶æ®µ1: çº§è”é˜´å½±è´´å›¾ (2-3å‘¨)**
1. å®ç°åŸºç¡€CSMæ¡†æ¶
2. çº§è”åˆ†å‰²ç®—æ³•ï¼ˆå¯¹æ•°ã€çº¿æ€§ã€æ··åˆï¼‰
3. å…‰ç…§çŸ©é˜µè®¡ç®—å’Œä¼˜åŒ–
4. çº§è”è¿‡æ¸¡æ¶ˆé™¤æ¥ç¼

**é˜¶æ®µ2: è½¯é˜´å½± (1-2å‘¨)**
1. PCFå®ç°ï¼ˆæ³Šæ¾é‡‡æ ·ï¼‰
2. PCSSå®ç°ï¼ˆåŠ¨æ€é˜´å½±è½¯åŒ–ï¼‰
3. æ€§èƒ½ä¼˜åŒ–ï¼ˆæ—©æœŸé€€å‡ºã€è‡ªé€‚åº”é‡‡æ ·ï¼‰

**é˜¶æ®µ3: ç‚¹å…‰æºå’Œèšå…‰ç¯é˜´å½± (1-2å‘¨)**
1. ç«‹æ–¹ä½“é˜´å½±è´´å›¾
2. å…¨å‘PCF
3. é˜´å½±å›¾é›†ç®¡ç†

---

### 2.4 åå¤„ç†æ•ˆæœç³»ç»Ÿ

#### 2.4.1 æ¶æ„è®¾è®¡

```mermaid
graph TB
    subgraph "Post-Processing Pipeline"
        SceneColor[åœºæ™¯é¢œè‰²] --> HDRBuffer[HDRç¼“å†²]
        
        HDRBuffer --> Bloom
        HDRBuffer --> SSAO[å±å¹•ç©ºé—´ç¯å¢ƒå…‰é®è”½]
        HDRBuffer --> SSR[å±å¹•ç©ºé—´åå°„]
        HDRBuffer --> MotionBlur[è¿åŠ¨æ¨¡ç³Š]
        HDRBuffer --> DOF[æ™¯æ·±]
        
        Bloom --> BrightPass[äº®åº¦æå–]
        BrightPass --> GaussianBlur[é«˜æ–¯æ¨¡ç³Š]
        GaussianBlur --> BloomComposite[åˆæˆ]
        
        SSAO --> SSAOBlur[SSAOæ¨¡ç³Š]
        
        BloomComposite --> ToneMapping[è‰²è°ƒæ˜ å°„]
        SSAOBlur --> ToneMapping
        SSR --> ToneMapping
        
        ToneMapping --> ColorGrading[é¢œè‰²åˆ†çº§]
        ColorGrading --> FXAA[æŠ—é”¯é½¿]
        FXAA --> FinalOutput[æœ€ç»ˆè¾“å‡º]
    end
    
    style HDRBuffer fill:#e1f5fe
    style Bloom fill:#fff3e0
    style ToneMapping fill:#f3e5f5
```

#### 2.4.2 æ ¸å¿ƒç»„ä»¶

**åå¤„ç†ç®¡ç†å™¨**
```cpp
class PostProcessingStack {
public:
    void addEffect(std::shared_ptr<PostProcessEffect> effect, int priority = 0);
    void removeEffect(const std::string& name);
    void setEffectEnabled(const std::string& name, bool enabled);
    
    void render(const RenderTarget& input, const RenderTarget& output);
    
private:
    struct EffectEntry {
        std::shared_ptr<PostProcessEffect> effect;
        int priority;
        bool enabled;
    };
    
    std::vector<EffectEntry> effects_;
    std::shared_ptr<RenderTarget> tempTargets_[2];  // Ping-pong buffers
};
```

**Bloom æ•ˆæœ**
```cpp
class BloomEffect : public PostProcessEffect {
public:
    struct Settings {
        float threshold = 1.0f;
        float intensity = 1.0f;
        float softThreshold = 0.5f;
        uint32_t iterations = 6;
        float scatter = 0.7f;
    };
    
    void setSettings(const Settings& settings);
    void render(const RenderTarget& input, const RenderTarget& output) override;
    
private:
    void extractBrightPixels(const RenderTarget& input);
    void downsampleAndBlur();
    void upsampleAndCombine();
    
    Settings settings_;
    std::vector<std::shared_ptr<RenderTarget>> mipChain_;
    std::shared_ptr<Shader> extractShader_;
    std::shared_ptr<Shader> downsampleShader_;
    std::shared_ptr<Shader> upsampleShader_;
};
```

**SSAO æ•ˆæœ**
```cpp
class SSAOEffect : public PostProcessEffect {
public:
    struct Settings {
        float radius = 0.5f;
        float bias = 0.025f;
        uint32_t sampleCount = 64;
        uint32_t blurSize = 4;
        float intensity = 1.0f;
    };
    
    void initialize();
    void setSettings(const Settings& settings);
    void render(const RenderTarget& input, const RenderTarget& output) override;
    
private:
    void generateSampleKernel();
    void generateNoiseTexture();
    void renderSSAO(const RenderTarget& input);
    void blurSSAO();
    
    Settings settings_;
    std::vector<glm::vec3> sampleKernel_;
    std::shared_ptr<Texture2D> noiseTexture_;
    std::shared_ptr<RenderTarget> ssaoTarget_;
    std::shared_ptr<RenderTarget> blurTarget_;
};
```

**è‰²è°ƒæ˜ å°„**
```cpp
class ToneMappingEffect : public PostProcessEffect {
public:
    enum class Operator {
        Reinhard,
        ReinhardExtended,
        Uncharted2,
        ACES,
        Filmic
    };
    
    struct Settings {
        Operator toneMappingOperator = Operator::ACES;
        float exposure = 1.0f;
        float whitePoint = 11.2f;
        bool autoExposure = false;
        float adaptationSpeed = 1.0f;
    };
    
    void setSettings(const Settings& settings);
    void render(const RenderTarget& input, const RenderTarget& output) override;
    
private:
    void calculateLuminance(const RenderTarget& input);
    void applyToneMapping(const RenderTarget& input, const RenderTarget& output);
    
    Settings settings_;
    std::shared_ptr<RenderTarget> luminanceTarget_;
    float currentExposure_ = 1.0f;
};
```

#### 2.4.3 å®ç°æ­¥éª¤

**é˜¶æ®µ1: åŸºç¡€æ¡†æ¶ (1å‘¨)**
1. å®ç°åå¤„ç†æ ˆç³»ç»Ÿ
2. Ping-pongç¼“å†²ç®¡ç†
3. æ•ˆæœä¼˜å…ˆçº§æ’åº

**é˜¶æ®µ2: æ ¸å¿ƒæ•ˆæœ (3-4å‘¨)**
1. Bloomæ•ˆæœï¼ˆäº®åº¦æå–ã€é«˜æ–¯æ¨¡ç³Šã€åˆæˆï¼‰
2. SSAOæ•ˆæœï¼ˆæ ·æœ¬ç”Ÿæˆã€æ·±åº¦é‡‡æ ·ã€æ¨¡ç³Šï¼‰
3. è‰²è°ƒæ˜ å°„ï¼ˆå¤šç§ç®—å­ã€è‡ªåŠ¨æ›å…‰ï¼‰
4. é¢œè‰²åˆ†çº§ï¼ˆLUTæ”¯æŒï¼‰

**é˜¶æ®µ3: é«˜çº§æ•ˆæœ (2-3å‘¨)**
1. å±å¹•ç©ºé—´åå°„ï¼ˆSSRï¼‰
2. è¿åŠ¨æ¨¡ç³Š
3. æ™¯æ·±ï¼ˆDOFï¼‰
4. è‰²å·®ã€æ™•å½±ç­‰é•œå¤´æ•ˆæœ

---

### 2.5 å…¨å±€å…‰ç…§ç³»ç»Ÿ

#### 2.5.1 æ¶æ„è®¾è®¡

```mermaid
graph TB
    subgraph "Global Illumination"
        GI[å…¨å±€å…‰ç…§ç³»ç»Ÿ] --> SSAO[å±å¹•ç©ºé—´AO]
        GI --> HBAO[HBAO+]
        GI --> SSR[å±å¹•ç©ºé—´åå°„]
        GI --> SSGI[å±å¹•ç©ºé—´å…¨å±€å…‰ç…§]
        GI --> VoxelGI[ä½“ç´ å…¨å±€å…‰ç…§]
        GI --> LightProbes[å…‰ç…§æ¢é’ˆ]
        
        VoxelGI --> VoxelConeTracing[ä½“ç´ é”¥è¿½è¸ª]
        LightProbes --> IrradianceProbes[è¾ç…§åº¦æ¢é’ˆ]
        LightProbes --> ReflectionProbes[åå°„æ¢é’ˆ]
    end
    
    style GI fill:#e1f5fe
    style VoxelGI fill:#fff3e0
    style LightProbes fill:#f3e5f5
```

#### 2.5.2 æ ¸å¿ƒç»„ä»¶

**å…‰ç…§æ¢é’ˆç³»ç»Ÿ**
```cpp
class LightProbeSystem {
public:
    struct ProbeVolume {
        glm::vec3 minBounds;
        glm::vec3 maxBounds;
        glm::ivec3 probeCount;
        std::vector<glm::vec3> probePositions;
    };
    
    void createProbeVolume(const ProbeVolume& volume);
    void bakeProbes(const Scene& scene);
    void updateDynamicProbes(const std::vector<Light*>& lights);
    
    glm::vec3 sampleIrradiance(const glm::vec3& position, const glm::vec3& normal) const;
    
private:
    std::vector<IrradianceProbe> probes_;
    std::shared_ptr<Texture3D> irradianceField_;
};

class IrradianceProbe {
public:
    void capture(const glm::vec3& position, const Scene& scene);
    void generateSphericalHarmonics();
    
    const std::array<glm::vec3, 9>& getSHCoefficients() const;
    
private:
    glm::vec3 position_;
    std::array<glm::vec3, 9> shCoefficients_;  // 9ä¸ªSHåŸºå‡½æ•°ç³»æ•°
    std::shared_ptr<TextureCubemap> environmentMap_;
};
```

**ä½“ç´ å…¨å±€å…‰ç…§**
```cpp
class VoxelGISystem {
public:
    struct Config {
        uint32_t voxelResolution = 128;
        glm::vec3 volumeSize = glm::vec3(100.0f);
        uint32_t coneCount = 6;
        float maxTraceDistance = 50.0f;
    };
    
    void initialize(const Config& config);
    void voxelize(const Scene& scene);
    void injectLighting(const std::vector<Light*>& lights);
    void propagateLight();
    void render(const GBuffer& gbuffer);
    
private:
    void generateMipmaps();
    void coneTracing(const glm::vec3& position, const glm::vec3& normal);
    
    Config config_;
    std::shared_ptr<Texture3D> voxelAlbedo_;
    std::shared_ptr<Texture3D> voxelNormal_;
    std::shared_ptr<Texture3D> voxelRadiance_;
};
```

#### 2.5.3 å®ç°æ­¥éª¤

**é˜¶æ®µ1: å…‰ç…§æ¢é’ˆ (2-3å‘¨)**
1. æ¢é’ˆç½‘æ ¼ç”Ÿæˆ
2. è¾ç…§åº¦æ•è·ï¼ˆç«‹æ–¹ä½“è´´å›¾ï¼‰
3. çƒè°å‡½æ•°å±•å¼€
4. è¿è¡Œæ—¶æ’å€¼

**é˜¶æ®µ2: å±å¹•ç©ºé—´GI (2-3å‘¨)**
1. SSAOå¢å¼ºï¼ˆHBAO+ï¼‰
2. å±å¹•ç©ºé—´åå°„ï¼ˆSSRï¼‰
3. å±å¹•ç©ºé—´å…¨å±€å…‰ç…§ï¼ˆSSGIï¼‰

**é˜¶æ®µ3: ä½“ç´ GI (3-4å‘¨)** *(å¯é€‰é«˜çº§åŠŸèƒ½)*
1. åœºæ™¯ä½“ç´ åŒ–
2. å…‰ç…§æ³¨å…¥
3. é”¥è¿½è¸ªå®ç°
4. å¤šçº§ç»†åŒ–å’Œä¼˜åŒ–

---

### 2.6 ä½“ç§¯æ¸²æŸ“ç³»ç»Ÿ

#### 2.6.1 æ¶æ„è®¾è®¡

```mermaid
graph TB
    subgraph "Volumetric Rendering"
        VolumeManager[ä½“ç§¯ç®¡ç†å™¨] --> VolumetricFog[ä½“ç§¯é›¾]
        VolumeManager --> VolumetricLight[ä½“ç§¯å…‰]
        VolumeManager --> VolumetricClouds[ä½“ç§¯äº‘]
        
        VolumetricFog --> RayMarching[å…‰çº¿æ­¥è¿›]
        VolumetricLight --> LightScattering[å…‰æ•£å°„]
        
        RayMarching --> NoiseTexture[å™ªå£°çº¹ç†]
        RayMarching --> DepthAwareUpsampling[æ·±åº¦æ„ŸçŸ¥ä¸Šé‡‡æ ·]
    end
    
    style VolumeManager fill:#e1f5fe
    style VolumetricFog fill:#fff3e0
```

#### 2.6.2 æ ¸å¿ƒç»„ä»¶

**ä½“ç§¯é›¾**
```cpp
class VolumetricFog {
public:
    struct Settings {
        float density = 0.01f;
        float heightFalloff = 0.1f;
        glm::vec3 scatteringColor = glm::vec3(1.0f);
        float anisotropy = 0.3f;  // ç›¸ä½å‡½æ•°å„å‘å¼‚æ€§
        uint32_t sampleCount = 64;
        float maxDistance = 100.0f;
    };
    
    void setSettings(const Settings& settings);
    void render(const Camera& camera, const std::vector<Light*>& lights);
    
private:
    void rayMarch(const Camera& camera);
    void integrate(const std::vector<Light*>& lights);
    void temporalFilter();
    
    Settings settings_;
    std::shared_ptr<Texture3D> densityVolume_;
    std::shared_ptr<RenderTarget> volumeTarget_;
};
```

**ä½“ç§¯å…‰ï¼ˆGod Raysï¼‰**
```cpp
class VolumetricLight {
public:
    struct Settings {
        uint32_t sampleCount = 100;
        float decay = 0.95f;
        float weight = 0.5f;
        float exposure = 0.2f;
    };
    
    void render(const DirectionalLight& sun, const Camera& camera);
    
private:
    void renderOccluders();
    void radialBlur(const glm::vec2& lightScreenPos);
    
    Settings settings_;
    std::shared_ptr<RenderTarget> occlusionTarget_;
};
```

#### 2.6.3 å®ç°æ­¥éª¤

**é˜¶æ®µ1: åŸºç¡€ä½“ç§¯é›¾ (2å‘¨)**
1. å…‰çº¿æ­¥è¿›å®ç°
2. æ·±åº¦æ„ŸçŸ¥åˆæˆ
3. åŸºç¡€å…‰æ•£å°„

**é˜¶æ®µ2: ä½“ç§¯å…‰ (1-2å‘¨)**
1. é®æŒ¡ç‰©æ¸²æŸ“
2. å¾„å‘æ¨¡ç³Š
3. ä¸åœºæ™¯åˆæˆ

**é˜¶æ®µ3: é«˜çº§æ•ˆæœ (2-3å‘¨)** *(å¯é€‰)*
1. 3Då™ªå£°ç”Ÿæˆ
2. æ—¶é—´æ»¤æ³¢é™å™ª
3. ä½“ç§¯äº‘æ¸²æŸ“

---

### 2.7 é«˜çº§ç²’å­ç³»ç»Ÿ

#### 2.7.1 æ¶æ„è®¾è®¡

```mermaid
graph TB
    subgraph "Advanced Particle System"
        ParticleSystem[ç²’å­ç³»ç»Ÿ] --> CPUParticles[CPUç²’å­]
        ParticleSystem --> GPUParticles[GPUç²’å­]
        
        GPUParticles --> ComputeShaderUpdate[è®¡ç®—ç€è‰²å™¨æ›´æ–°]
        GPUParticles --> InstancedRendering[å®ä¾‹åŒ–æ¸²æŸ“]
        
        ParticleEmitter[ç²’å­å‘å°„å™¨] --> EmitterShapes[å‘å°„å™¨å½¢çŠ¶]
        EmitterShapes --> Point[ç‚¹]
        EmitterShapes --> Sphere[çƒä½“]
        EmitterShapes --> Box[ç›’å­]
        EmitterShapes --> Cone[é”¥ä½“]
        EmitterShapes --> Mesh[ç½‘æ ¼è¡¨é¢]
        
        ParticleForces[ç²’å­åŠ›åœº] --> Gravity[é‡åŠ›]
        ParticleForces --> Wind[é£åŠ›]
        ParticleForces --> Vortex[æ¶¡æµ]
        ParticleForces --> Attractor[å¸å¼•å­]
    end
    
    style ParticleSystem fill:#e1f5fe
    style GPUParticles fill:#fff3e0
```

#### 2.7.2 æ ¸å¿ƒç»„ä»¶

**GPUç²’å­ç³»ç»Ÿ**
```cpp
class GPUParticleSystem {
public:
    struct Particle {
        glm::vec3 position;
        float life;
        glm::vec3 velocity;
        float size;
        glm::vec4 color;
        glm::vec3 acceleration;
        float rotation;
    };
    
    struct EmitterConfig {
        uint32_t maxParticles = 10000;
        float emissionRate = 100.0f;
        float lifetime = 5.0f;
        float lifetimeVariance = 1.0f;
        glm::vec3 initialVelocity;
        float velocityVariance;
    };
    
    void initialize(const EmitterConfig& config);
    void update(float deltaTime);
    void render(const Camera& camera);
    
private:
    void emit(uint32_t count);
    void updateParticlesOnGPU();
    void sortParticles(const Camera& camera);
    
    EmitterConfig config_;
    std::shared_ptr<StorageBuffer> particleBuffer_;
    std::shared_ptr<ComputeShader> updateShader_;
    std::shared_ptr<ComputeShader> emitShader_;
    uint32_t aliveCount_ = 0;
};
```

#### 2.7.3 å®ç°æ­¥éª¤

**é˜¶æ®µ1: GPUç²’å­åŸºç¡€ (2å‘¨)**
1. ç²’å­å­˜å‚¨ç¼“å†²ï¼ˆSSBOï¼‰
2. è®¡ç®—ç€è‰²å™¨æ›´æ–°
3. å®ä¾‹åŒ–æ¸²æŸ“

**é˜¶æ®µ2: ç‰©ç†æ¨¡æ‹Ÿ (1-2å‘¨)**
1. åŠ›åœºç³»ç»Ÿ
2. ç¢°æ’æ£€æµ‹
3. ç²’å­é—´äº¤äº’

**é˜¶æ®µ3: é«˜çº§ç‰¹æ€§ (1-2å‘¨)**
1. ç²’å­æ’åºï¼ˆæ·±åº¦æ’åºï¼‰
2. ç²’å­å…‰ç…§
3. è½¯ç²’å­ï¼ˆæ·±åº¦æ·¡åŒ–ï¼‰

---

### 2.8 åœ°å½¢æ¸²æŸ“ç³»ç»Ÿ

#### 2.8.1 æ¶æ„è®¾è®¡

```mermaid
graph TB
    subgraph "Terrain System"
        TerrainManager[åœ°å½¢ç®¡ç†å™¨] --> HeightmapTerrain[é«˜åº¦å›¾åœ°å½¢]
        TerrainManager --> VoxelTerrain[ä½“ç´ åœ°å½¢]
        
        HeightmapTerrain --> QuadTree[å››å‰æ ‘LOD]
        HeightmapTerrain --> Tessellation[ç»†åˆ†æ›²é¢]
        HeightmapTerrain --> Splatting[å¤šå±‚çº¹ç†æ··åˆ]
        
        Splatting --> AlbedoLayers[åç…§ç‡å±‚]
        Splatting --> NormalLayers[æ³•çº¿å±‚]
        Splatting --> SplatMap[æ··åˆè´´å›¾]
        
        VoxelTerrain --> MarchingCubes[Marching Cubes]
        VoxelTerrain --> DualContouring[Dual Contouring]
    end
    
    style TerrainManager fill:#e1f5fe
    style HeightmapTerrain fill:#fff3e0
```

#### 2.8.2 æ ¸å¿ƒç»„ä»¶

**é«˜åº¦å›¾åœ°å½¢**
```cpp
class HeightmapTerrain {
public:
    struct Config {
        std::string heightmapPath;
        float heightScale = 100.0f;
        float tileSize = 1.0f;
        uint32_t patchResolution = 64;
        uint32_t maxLODLevel = 5;
    };
    
    void load(const Config& config);
    void update(const Camera& camera);
    void render();
    
    float getHeight(float x, float z) const;
    glm::vec3 getNormal(float x, float z) const;
    
private:
    void buildQuadTree();
    void selectLOD(const Camera& camera);
    void generateMesh(uint32_t lodLevel);
    
    Config config_;
    std::shared_ptr<Texture2D> heightmap_;
    std::unique_ptr<TerrainQuadTree> quadTree_;
    std::vector<std::shared_ptr<Mesh>> lodMeshes_;
};
```

**çº¹ç†æ··åˆ**
```cpp
class TerrainSplatting {
public:
    struct Layer {
        std::shared_ptr<Texture2D> albedo;
        std::shared_ptr<Texture2D> normal;
        std::shared_ptr<Texture2D> roughness;
        float tiling = 1.0f;
    };
    
    void addLayer(const Layer& layer);
    void setSplatMap(std::shared_ptr<Texture2D> splatMap);
    void setTriplanarMapping(bool enabled);
    
    void bindTextures(const Shader& shader);
    
private:
    std::vector<Layer> layers_;
    std::shared_ptr<Texture2D> splatMap_;
    bool triplanarMapping_ = false;
};
```

#### 2.8.3 å®ç°æ­¥éª¤

**é˜¶æ®µ1: åŸºç¡€åœ°å½¢ (2-3å‘¨)**
1. é«˜åº¦å›¾åŠ è½½
2. åŸºç¡€ç½‘æ ¼ç”Ÿæˆ
3. å››å‰æ ‘LODç³»ç»Ÿ

**é˜¶æ®µ2: çº¹ç†ç³»ç»Ÿ (2å‘¨)**
1. å¤šå±‚çº¹ç†æ··åˆ
2. æ··åˆè´´å›¾æ”¯æŒ
3. ä¸‰å¹³é¢æ˜ å°„

**é˜¶æ®µ3: é«˜çº§ç‰¹æ€§ (2-3å‘¨)** *(å¯é€‰)*
1. æ›²é¢ç»†åˆ†
2. ä½ç§»è´´å›¾
3. åœ°å½¢ç¼–è¾‘å·¥å…·

---

## 3. å®ç°è·¯çº¿å›¾

### 3.1 å¼€å‘ä¼˜å…ˆçº§å»ºè®®

**ç¬¬ä¸€é˜¶æ®µ (æ ¸å¿ƒæ¸²æŸ“æå‡) - 8-10å‘¨**
1. âœ… **PBRæè´¨ç³»ç»Ÿ** (3å‘¨)
   - Week 1-2: åŸºç¡€PBRæè´¨
   - Week 3: IBLç³»ç»Ÿ

2. âœ… **åå¤„ç†ç³»ç»Ÿ** (3å‘¨)
   - Week 1: æ¡†æ¶ + Bloom
   - Week 2: SSAO + è‰²è°ƒæ˜ å°„
   - Week 3: é¢œè‰²åˆ†çº§ + æŠ—é”¯é½¿

3. âœ… **é˜´å½±ç³»ç»Ÿå¢å¼º** (2-3å‘¨)
   - Week 1-2: çº§è”é˜´å½±è´´å›¾
   - Week 3: PCFè½¯é˜´å½±

**ç¬¬äºŒé˜¶æ®µ (æ€§èƒ½ä¸å…‰ç…§) - 6-8å‘¨**
4. âœ… **å»¶è¿Ÿæ¸²æŸ“ç®¡çº¿** (4-5å‘¨)
   - Week 1-2: åŸºç¡€å»¶è¿Ÿæ¸²æŸ“
   - Week 3: åˆ†å—å…‰ç…§
   - Week 4-5: èšç°‡å…‰ç…§

5. âœ… **å…‰ç…§æ¢é’ˆç³»ç»Ÿ** (2-3å‘¨)
   - è¾ç…§åº¦æ¢é’ˆ
   - åå°„æ¢é’ˆ

**ç¬¬ä¸‰é˜¶æ®µ (é«˜çº§æ•ˆæœ) - 6-8å‘¨** *(å¯é€‰)*
6. **ä½“ç§¯æ¸²æŸ“** (2-3å‘¨)
7. **GPUç²’å­ç³»ç»Ÿ** (2å‘¨)
8. **åœ°å½¢ç³»ç»Ÿ** (2-3å‘¨)

### 3.2 æŠ€æœ¯ä¾èµ–å…³ç³»

```mermaid
graph LR
    PBR[PBRæè´¨] --> Deferred[å»¶è¿Ÿæ¸²æŸ“]
    Shadow[é˜´å½±ç³»ç»Ÿ] --> Deferred
    Deferred --> GI[å…¨å±€å…‰ç…§]
    PostProcess[åå¤„ç†] --> Volume[ä½“ç§¯æ¸²æŸ“]
    GI --> Volume
    
    style PBR fill:#90EE90
    style Shadow fill:#90EE90
    style PostProcess fill:#90EE90
    style Deferred fill:#FFD700
    style GI fill:#FFD700
    style Volume fill:#87CEEB
```

**å›¾ä¾‹**:
- ğŸŸ¢ ç»¿è‰²: ç¬¬ä¸€é˜¶æ®µï¼ˆå¿…é¡»ï¼‰
- ğŸŸ¡ é»„è‰²: ç¬¬äºŒé˜¶æ®µï¼ˆæ¨èï¼‰
- ğŸ”µ è“è‰²: ç¬¬ä¸‰é˜¶æ®µï¼ˆå¯é€‰ï¼‰

---

## 4. é›†æˆæŒ‡å—

### 4.1 ä¸ç°æœ‰ç³»ç»Ÿé›†æˆ

**ECSç»„ä»¶æ‰©å±•**
```cpp
// æ–°å¢æ¸²æŸ“ç»„ä»¶
struct PBRMaterialComponent : public Component {
    std::shared_ptr<PBRMaterial> material;
};

struct PostProcessVolumeComponent : public Component {
    std::shared_ptr<PostProcessingStack> effects;
    AABB bounds;  // å½±å“èŒƒå›´
    float blendDistance = 1.0f;
};

struct LightProbeComponent : public Component {
    std::shared_ptr<IrradianceProbe> probe;
    bool isDynamic = false;
};
```

**æ¸²æŸ“ç³»ç»Ÿæ‰©å±•**
```cpp
class AdvancedRenderSystem : public System {
public:
    void initialize() override {
        // åˆå§‹åŒ–é«˜çº§æ¸²æŸ“ç®¡çº¿
        deferredRenderer_ = std::make_unique<DeferredRenderer>();
        postProcessStack_ = std::make_unique<PostProcessingStack>();
        shadowManager_ = std::make_unique<ShadowManager>();
        
        // æ·»åŠ åå¤„ç†æ•ˆæœ
        postProcessStack_->addEffect(std::make_shared<BloomEffect>(), 100);
        postProcessStack_->addEffect(std::make_shared<SSAOEffect>(), 90);
        postProcessStack_->addEffect(std::make_shared<ToneMappingEffect>(), 80);
    }
    
    void update(float deltaTime) override {
        // æŸ¥è¯¢éœ€è¦æ¸²æŸ“çš„å®ä½“
        auto view = world_->view<TransformComponent, PBRMaterialComponent>();
        
        // é˜´å½±æ¸²æŸ“
        shadowManager_->renderShadows(view);
        
        // å»¶è¿Ÿæ¸²æŸ“
        deferredRenderer_->renderGeometry(view);
        deferredRenderer_->renderLighting();
        
        // åå¤„ç†
        postProcessStack_->render(deferredRenderer_->getOutput(), finalOutput_);
    }
    
private:
    std::unique_ptr<DeferredRenderer> deferredRenderer_;
    std::unique_ptr<PostProcessingStack> postProcessStack_;
    std::unique_ptr<ShadowManager> shadowManager_;
};
```

### 4.2 ç€è‰²å™¨ç®¡ç†

**ç€è‰²å™¨å˜ä½“ç³»ç»Ÿ**
```cpp
class ShaderVariantManager {
public:
    struct Defines {
        bool USE_PBR = false;
        bool USE_NORMAL_MAP = false;
        bool USE_AO_MAP = false;
        bool USE_EMISSIVE_MAP = false;
        uint32_t SHADOW_CASCADE_COUNT = 4;
        bool USE_PCF_SOFT_SHADOWS = false;
    };
    
    std::shared_ptr<Shader> getOrCreateVariant(
        const std::string& baseName,
        const Defines& defines
    );
    
private:
    std::unordered_map<std::string, std::shared_ptr<Shader>> variantCache_;
    std::string generateDefineString(const Defines& defines);
};
```

### 4.3 æ€§èƒ½é…ç½®

**æ¸²æŸ“è´¨é‡é¢„è®¾**
```cpp
enum class RenderQuality {
    Low,
    Medium,
    High,
    Ultra
};

struct RenderQualitySettings {
    // é˜´å½±è®¾ç½®
    uint32_t shadowMapResolution;
    uint32_t cascadeCount;
    bool softShadows;
    
    // åå¤„ç†è®¾ç½®
    bool enableBloom;
    bool enableSSAO;
    uint32_t ssaoSampleCount;
    
    // LODè®¾ç½®
    float lodBias;
    
    static RenderQualitySettings getPreset(RenderQuality quality) {
        switch (quality) {
            case RenderQuality::Low:
                return {1024, 2, false, false, false, 16, 0.5f};
            case RenderQuality::Medium:
                return {2048, 3, true, true, true, 32, 0.0f};
            case RenderQuality::High:
                return {2048, 4, true, true, true, 64, 0.0f};
            case RenderQuality::Ultra:
                return {4096, 4, true, true, true, 64, -0.5f};
        }
    }
};
```

---

## 5. æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 5.1 GPUä¼˜åŒ–

1. **æ‰¹å¤„ç†ä¼˜åŒ–**
   - å»¶è¿Ÿæ¸²æŸ“å¤©ç„¶æ”¯æŒæ‰¹å¤„ç†
   - ç›¸åŒæè´¨çš„ç‰©ä½“åˆ†ç»„æ¸²æŸ“
   - ä½¿ç”¨å®ä¾‹åŒ–æ¸²æŸ“é‡å¤å¯¹è±¡

2. **å†…å­˜ä¼˜åŒ–**
   - G-Bufferå‹ç¼©ï¼ˆæ³•çº¿å‹ç¼©ã€é¢œè‰²æ‰“åŒ…ï¼‰
   - çº¹ç†å‹ç¼©ï¼ˆBC7/ASTCï¼‰
   - æµå¼çº¹ç†åŠ è½½

3. **å¸¦å®½ä¼˜åŒ–**
   - Early-Z pass
   - æ·±åº¦é¢„æ¸²æŸ“
   - é™ä½G-Bufferåˆ†è¾¨ç‡ï¼ˆå¯é€‰ï¼‰

### 5.2 CPUä¼˜åŒ–

1. **å¤šçº¿ç¨‹æ¸²æŸ“**
   ```cpp
   class ParallelRenderQueue {
   public:
       void submit(RenderCommand cmd, uint32_t threadId);
       void execute();  // åœ¨ä¸»çº¿ç¨‹æ‰§è¡Œæ‰€æœ‰å‘½ä»¤
       
   private:
       std::vector<std::vector<RenderCommand>> perThreadQueues_;
   };
   ```

2. **å‰”é™¤ä¼˜åŒ–**
   - è§†é”¥å‰”é™¤
   - é®æŒ¡å‰”é™¤ï¼ˆå¯é€‰ï¼‰
   - LODè·ç¦»è®¡ç®—æ‰¹å¤„ç†

### 5.3 è°ƒè¯•å·¥å…·

**æ¸²æŸ“è°ƒè¯•å™¨**
```cpp
class RenderDebugger {
public:
    enum class DebugView {
        None,
        Albedo,
        Normal,
        Metallic,
        Roughness,
        AO,
        Emissive,
        Depth,
        ShadowCascades,
        Overdraw,
        LightHeatmap
    };
    
    void setDebugView(DebugView view);
    void drawUI();  // ImGuié¢æ¿
    
private:
    DebugView currentView_ = DebugView::None;
    bool showStats_ = true;
    bool showLightVolumes_ = false;
};
```

---

## 6. æµ‹è¯•ä¸éªŒè¯

### 6.1 è§†è§‰æµ‹è¯•åœºæ™¯

å»ºè®®åˆ›å»ºä»¥ä¸‹æµ‹è¯•åœºæ™¯ï¼š

1. **PBRæè´¨æµ‹è¯•**
   - é‡‘å±çƒé˜µåˆ—ï¼ˆé‡‘å±åº¦0-1ï¼Œç²—ç³™åº¦0-1ï¼‰
   - ä¸åŒæè´¨å¯¹æ¯”ï¼ˆé‡‘å±ã€å¡‘æ–™ã€æœ¨å¤´ã€å¸ƒæ–™ï¼‰

2. **å…‰ç…§æµ‹è¯•**
   - å¤šå…‰æºåœºæ™¯ï¼ˆæµ‹è¯•å»¶è¿Ÿæ¸²æŸ“æ€§èƒ½ï¼‰
   - IBLç¯å¢ƒæµ‹è¯•ï¼ˆå®¤å†…ã€å®¤å¤–ã€å¤œæ™šï¼‰

3. **é˜´å½±æµ‹è¯•**
   - çº§è”è¿‡æ¸¡æµ‹è¯•
   - è½¯é˜´å½±è´¨é‡æµ‹è¯•
   - æ€§èƒ½å‹åŠ›æµ‹è¯•

### 6.2 æ€§èƒ½åŸºå‡†æµ‹è¯•

```cpp
class PerformanceBenchmark {
public:
    struct Metrics {
        float frameTime;
        float geometryPassTime;
        float lightingPassTime;
        float shadowPassTime;
        float postProcessTime;
        uint32_t drawCalls;
        uint32_t triangles;
    };
    
    void startFrame();
    void endFrame();
    Metrics getMetrics() const;
    void exportToCSV(const std::string& filename);
    
private:
    std::vector<Metrics> frameHistory_;
};
```

---

## 7. æ–‡æ¡£ä¸ç¤ºä¾‹

### 7.1 éœ€è¦ç¼–å†™çš„æ–‡æ¡£

1. **APIæ–‡æ¡£**
   - å„ç³»ç»Ÿçš„å…¬å…±æ¥å£
   - ç»„ä»¶ä½¿ç”¨è¯´æ˜
   - ç€è‰²å™¨æ¥å£è§„èŒƒ

2. **æ•™ç¨‹æ–‡æ¡£**
   - PBRæè´¨åˆ›å»ºæ•™ç¨‹
   - åå¤„ç†æ•ˆæœé…ç½®æŒ‡å—
   - æ€§èƒ½ä¼˜åŒ–æœ€ä½³å®è·µ

3. **æŠ€æœ¯ç™½çš®ä¹¦**
   - å»¶è¿Ÿæ¸²æŸ“å®ç°ç»†èŠ‚
   - é˜´å½±ç®—æ³•å¯¹æ¯”
   - æ€§èƒ½åˆ†ææŠ¥å‘Š

### 7.2 ç¤ºä¾‹ä»£ç 

**ç¤ºä¾‹1: åˆ›å»ºPBRæè´¨**
```cpp
// åˆ›å»ºPBRæè´¨
auto material = std::make_shared<PBRMaterial>();
material->setAlbedo(glm::vec3(0.8f, 0.1f, 0.1f));
material->setMetallic(0.0f);
material->setRoughness(0.5f);
material->loadAlbedoMap("textures/metal_albedo.png");
material->loadNormalMap("textures/metal_normal.png");

// åº”ç”¨åˆ°å®ä½“
auto entity = world->createEntity();
entity.addComponent<PBRMaterialComponent>(material);
```

**ç¤ºä¾‹2: é…ç½®åå¤„ç†**
```cpp
// åˆ›å»ºåå¤„ç†æ ˆ
auto postProcess = std::make_shared<PostProcessingStack>();

// æ·»åŠ Bloom
auto bloom = std::make_shared<BloomEffect>();
bloom->setIntensity(0.8f);
bloom->setThreshold(1.2f);
postProcess->addEffect(bloom);

// æ·»åŠ è‰²è°ƒæ˜ å°„
auto toneMapping = std::make_shared<ToneMappingEffect>();
toneMapping->setOperator(ToneMappingEffect::Operator::ACES);
toneMapping->setExposure(1.5f);
postProcess->addEffect(toneMapping);
```

---

## 8. æœªæ¥æ‰©å±•æ–¹å‘

### 8.1 çŸ­æœŸæ‰©å±• (6-12ä¸ªæœˆ)

1. **å…‰çº¿è¿½è¸ªæ”¯æŒ**
   - å®æ—¶å…‰çº¿è¿½è¸ªåå°„
   - å…‰çº¿è¿½è¸ªé˜´å½±
   - å…‰çº¿è¿½è¸©å…¨å±€å…‰ç…§

2. **è™šæ‹Ÿçº¹ç†ç³»ç»Ÿ**
   - Sparse Virtual Textures
   - æµå¼çº¹ç†åŠ è½½
   - å†…å­˜ç®¡ç†ä¼˜åŒ–

3. **é«˜çº§åŠ¨ç”»ç³»ç»Ÿ**
   - éª¨éª¼åŠ¨ç”»
   - é¡¶ç‚¹åŠ¨ç”»
   - å¸ƒæ–™æ¨¡æ‹Ÿ

### 8.2 é•¿æœŸæ„¿æ™¯ (1-2å¹´)

1. **å®Œæ•´çš„PBRå·¥ä½œæµ**
   - æè´¨ç¼–è¾‘å™¨
   - èŠ‚ç‚¹å¼ç€è‰²å™¨ç¼–è¾‘
   - å®æ—¶é¢„è§ˆ

2. **ç”µå½±çº§æ¸²æŸ“**
   - è·¯å¾„è¿½è¸ª
   - åŒå‘è·¯å¾„è¿½è¸ª
   - å…‰å­æ˜ å°„

3. **ä¸–ç•Œæ¸²æŸ“**
   - å¤§è§„æ¨¡åœ°å½¢
   - æµ·æ´‹æ¸²æŸ“
   - å¤§æ°”æ•£å°„
   - å¤©ç©ºç›’ç³»ç»Ÿ

---

## 9. æ€»ç»“

### 9.1 æ ¸å¿ƒä»·å€¼

è¿™å¥—é«˜çº§æ¸²æŸ“åŠŸèƒ½æ‰©å±•æ–¹æ¡ˆå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

1. **æ¸è¿›å¼å®ç°** - æŒ‰ä¼˜å…ˆçº§åˆ†é˜¶æ®µå¼€å‘ï¼Œæ¯ä¸ªé˜¶æ®µéƒ½æœ‰å¯ç”¨æˆæœ
2. **æ¨¡å—åŒ–è®¾è®¡** - å„åŠŸèƒ½ç‹¬ç«‹ï¼Œå¯æŒ‰éœ€å¯ç”¨
3. **æ€§èƒ½ä¼˜å…ˆ** - è€ƒè™‘äº†ç§»åŠ¨ç«¯å’Œä½ç«¯è®¾å¤‡çš„å…¼å®¹æ€§
4. **å¯æ‰©å±•æ€§å¼º** - ä¸ºæœªæ¥åŠŸèƒ½é¢„ç•™æ¥å£

### 9.2 æ¨èå®æ–½æ­¥éª¤

**ç«‹å³å¼€å§‹**:
1. PBRæè´¨ç³»ç»Ÿ - æå‡è§†è§‰è´¨é‡çš„æœ€å¿«æ–¹å¼
2. åå¤„ç†ç³»ç»Ÿ - ä½æˆæœ¬é«˜å›æŠ¥çš„è§†è§‰æå‡

**çŸ­æœŸç›®æ ‡** (3ä¸ªæœˆ):
3. é˜´å½±ç³»ç»Ÿå¢å¼º - æ˜¾è‘—æ”¹å–„åœºæ™¯çœŸå®æ„Ÿ
4. å»¶è¿Ÿæ¸²æŸ“ç®¡çº¿ - ä¸ºå¤§é‡å…‰æºæ‰“ä¸‹åŸºç¡€

**ä¸­æœŸç›®æ ‡** (6ä¸ªæœˆ):
5. å…¨å±€å…‰ç…§ç³»ç»Ÿ - è¾¾åˆ°ç°ä»£æ¸²æŸ“æ ‡å‡†

**é•¿æœŸç›®æ ‡** (12ä¸ªæœˆ):
6. ä½“ç§¯æ¸²æŸ“ã€ç²’å­ã€åœ°å½¢ç­‰ä¸“é¡¹ç³»ç»Ÿ

### 9.3 é¢„æœŸæ•ˆæœ

å®Œæˆç¬¬ä¸€é˜¶æ®µåï¼Œæ‚¨çš„æ¸²æŸ“å¼•æ“å°†è¾¾åˆ°ï¼š
- âœ… ç°ä»£æ¸¸æˆçš„è§†è§‰è´¨é‡æ ‡å‡†
- âœ… è‰¯å¥½çš„æ€§èƒ½è¡¨ç°
- âœ… çµæ´»çš„æè´¨ç³»ç»Ÿ
- âœ… ä¸°å¯Œçš„åå¤„ç†æ•ˆæœ

å®Œæˆç¬¬äºŒé˜¶æ®µåï¼Œå°†æ”¯æŒï¼š
- âœ… å¤§è§„æ¨¡åŠ¨æ€å…‰ç…§
- âœ… å…¨å±€å…‰ç…§æ•ˆæœ
- âœ… æ¥è¿‘AAAæ¸¸æˆçš„æ¸²æŸ“è´¨é‡

---
