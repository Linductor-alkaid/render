# ç¢°æ’æ£€æµ‹ç³»ç»Ÿä¿®å¤ä¸ä¼˜åŒ–æ–¹æ¡ˆ

## é—®é¢˜è¯Šæ–­

æ ¹æ®ä»£ç åˆ†æï¼Œå½“å‰ç³»ç»Ÿå­˜åœ¨ä»¥ä¸‹å…³é”®é—®é¢˜ï¼š

### 1. **SphereVsBox è¾¹ç•Œæƒ…å†µå¤„ç†ä¸å½“**
- çƒå¿ƒåœ¨ç›’å­å†…éƒ¨æ—¶çš„æ³•çº¿è®¡ç®—å¯èƒ½ä¸ç¨³å®š
- æ¥è§¦ç‚¹è®¡ç®—åœ¨æŸäº›æƒ…å†µä¸‹ä¸å‡†ç¡®
- æ³•çº¿æ–¹å‘å¯èƒ½æŒ‡å‘é”™è¯¯

### 2. **ContactManifold æ³•çº¿æ–¹å‘ä¸ä¸€è‡´**
- ä¸åŒç¢°æ’ç±»å‹çš„æ³•çº¿æ–¹å‘çº¦å®šä¸ç»Ÿä¸€
- Dispatcher ä¸­çš„æ³•çº¿ç¿»è½¬é€»è¾‘å¯èƒ½å¯¼è‡´é”™è¯¯

### 3. **æ•°å€¼ç²¾åº¦é—®é¢˜**
- æµ®ç‚¹æ•°æ¯”è¾ƒç¼ºä¹å®¹å·®å¤„ç†
- æå°ç©¿é€æ·±åº¦å¯èƒ½è¢«å¿½ç•¥

---

## ä¿®å¤æ–¹æ¡ˆ

### æ–¹æ¡ˆ 1ï¼šä¿®å¤ SphereVsBox æ ¸å¿ƒé€»è¾‘

#### é—®é¢˜æ ¹æº
```cpp
// å½“å‰ä»£ç é—®é¢˜ï¼š
// 1. çƒå¿ƒåœ¨ç›’å†…æ—¶ï¼Œæ³•çº¿è®¡ç®—ä¾èµ–å±€éƒ¨åæ ‡ç¬¦å·ï¼Œå¯èƒ½ä¸ç¨³å®š
// 2. æ¥è§¦ç‚¹ä½ç½®è®¡ç®—ä¸ä¸€è‡´
// 3. æ³•çº¿æ–¹å‘çº¦å®šä¸æ˜ç¡®
```

#### ä¿®å¤ä»£ç 

```cpp
bool CollisionDetector::SphereVsBox(
    const Vector3& sphereCenter, float sphereRadius,
    const Vector3& boxCenter, const Vector3& boxHalfExtents,
    const Quaternion& boxRotation,
    ContactManifold& manifold
) {
    // è½¬æ¢åˆ°ç›’å­å±€éƒ¨ç©ºé—´
    Matrix3 rotMatrix = boxRotation.toRotationMatrix();
    Vector3 localCenter = rotMatrix.transpose() * (sphereCenter - boxCenter);
    
    // è®¡ç®—ç›’å­ä¸Šæœ€è¿‘çš„ç‚¹ï¼ˆå±€éƒ¨ç©ºé—´ï¼‰
    Vector3 closestLocal = localCenter.cwiseMax(-boxHalfExtents).cwiseMin(boxHalfExtents);
    
    // è½¬å›ä¸–ç•Œç©ºé—´
    Vector3 closestWorld = boxCenter + rotMatrix * closestLocal;
    
    // è®¡ç®—è·ç¦»å‘é‡
    Vector3 delta = sphereCenter - closestWorld;
    float distSq = delta.squaredNorm();
    float radiusSq = sphereRadius * sphereRadius;
    
    // ä¸ç›¸äº¤æ£€æµ‹
    if (distSq > radiusSq + MathUtils::EPSILON) {
        return false;
    }
    
    float dist = std::sqrt(distSq);
    
    // ===== å…³é”®ä¿®å¤ï¼šçƒå¿ƒåœ¨ç›’å†…çš„æƒ…å†µ =====
    if (dist < MathUtils::EPSILON) {
        // çƒå¿ƒå‡ ä¹å®Œå…¨åœ¨ç›’å†…ï¼Œéœ€è¦æ‰¾åˆ°æœ€è¿‘çš„é¢
        Vector3 distToFaces = boxHalfExtents - localCenter.cwiseAbs();
        
        // æ‰¾åˆ°è·ç¦»æœ€å°çš„è½´
        int minAxis = 0;
        float minDist = distToFaces.x();
        
        if (distToFaces.y() < minDist) {
            minAxis = 1;
            minDist = distToFaces.y();
        }
        if (distToFaces.z() < minDist) {
            minAxis = 2;
            minDist = distToFaces.z();
        }
        
        // æ„é€ å±€éƒ¨æ³•çº¿ï¼ˆä»ç›’å­æŒ‡å‘çƒå¿ƒï¼‰
        Vector3 localNormal = Vector3::Zero();
        localNormal[minAxis] = (localCenter[minAxis] > 0) ? 1.0f : -1.0f;
        
        // è½¬æ¢åˆ°ä¸–ç•Œç©ºé—´
        Vector3 normal = rotMatrix * localNormal;
        
        // æ³•çº¿ç»Ÿä¸€çº¦å®šï¼šä»ç›’å­æŒ‡å‘çƒä½“
        manifold.SetNormal(normal);
        manifold.penetration = sphereRadius + minDist;
        
        // æ¥è§¦ç‚¹ï¼šçƒè¡¨é¢ä¸Šï¼Œæ²¿æ³•çº¿æ–¹å‘
        Vector3 contactPoint = sphereCenter - normal * sphereRadius;
        manifold.AddContact(contactPoint, manifold.penetration);
        
        return true;
    }
    
    // ===== æ­£å¸¸ç¢°æ’æƒ…å†µ =====
    // æ³•çº¿ä»ç›’å­æŒ‡å‘çƒå¿ƒ
    Vector3 normal = delta / dist;
    manifold.SetNormal(normal);
    manifold.penetration = sphereRadius - dist;
    
    // æ¥è§¦ç‚¹ï¼šåœ¨ç›’å­è¡¨é¢
    Vector3 contactPoint = closestWorld;
    manifold.AddContact(contactPoint, manifold.penetration);
    
    return true;
}
```

---

### æ–¹æ¡ˆ 2ï¼šç»Ÿä¸€æ³•çº¿æ–¹å‘çº¦å®š

#### æ ¸å¿ƒåŸåˆ™
**æ‰€æœ‰ç¢°æ’æ£€æµ‹å‡½æ•°çš„æ³•çº¿æ–¹å‘ç»Ÿä¸€çº¦å®šï¼šä»ç‰©ä½“AæŒ‡å‘ç‰©ä½“B**

#### ä¿®æ”¹ CollisionDispatcher

```cpp
bool CollisionDispatcher::Detect(
    const CollisionShape* shapeA, const Vector3& posA, const Quaternion& rotA, const Vector3& scaleA,
    const CollisionShape* shapeB, const Vector3& posB, const Quaternion& rotB, const Vector3& scaleB,
    ContactManifold& manifold
) {
    if (!shapeA || !shapeB) {
        return false;
    }
    
    manifold.Clear();
    
    ShapeType typeA = shapeA->GetType();
    ShapeType typeB = shapeB->GetType();
    
    // ä¼˜å…ˆçº§ï¼šSphere > Box > Capsule
    if (typeA == ShapeType::Sphere && typeB == ShapeType::Sphere) {
        const SphereShape* sphereA = static_cast<const SphereShape*>(shapeA);
        const SphereShape* sphereB = static_cast<const SphereShape*>(shapeB);
        float radiusA = sphereA->GetRadius() * scaleA.maxCoeff();
        float radiusB = sphereB->GetRadius() * scaleB.maxCoeff();
        return CollisionDetector::SphereVsSphere(posA, radiusA, posB, radiusB, manifold);
    }
    
    if (typeA == ShapeType::Sphere && typeB == ShapeType::Box) {
        const SphereShape* sphere = static_cast<const SphereShape*>(shapeA);
        const BoxShape* box = static_cast<const BoxShape*>(shapeB);
        float radius = sphere->GetRadius() * scaleA.maxCoeff();
        Vector3 halfExtents = box->GetHalfExtents().cwiseProduct(scaleB);
        
        // ç›´æ¥è°ƒç”¨ï¼Œæ³•çº¿ä»çƒæŒ‡å‘ç›’å­éœ€è¦åè½¬
        bool result = CollisionDetector::SphereVsBox(
            posA, radius, posB, halfExtents, rotB, manifold
        );
        
        // ä¿®æ­£ï¼šSphereVsBox è¿”å›çš„æ³•çº¿æ˜¯ä»ç›’å­åˆ°çƒï¼Œéœ€è¦åè½¬ä¸ºä»Aåˆ°B
        if (result) {
            manifold.SetNormal(-manifold.normal);
        }
        return result;
    }
    
    if (typeA == ShapeType::Box && typeB == ShapeType::Sphere) {
        const BoxShape* box = static_cast<const BoxShape*>(shapeA);
        const SphereShape* sphere = static_cast<const SphereShape*>(shapeB);
        Vector3 halfExtents = box->GetHalfExtents().cwiseProduct(scaleA);
        float radius = sphere->GetRadius() * scaleB.maxCoeff();
        
        // SphereVsBox(sphere, box) è¿”å›æ³•çº¿ä»ç›’å­åˆ°çƒï¼Œæ­£å¥½æ˜¯ä»Aåˆ°B
        return CollisionDetector::SphereVsBox(
            posB, radius, posA, halfExtents, rotA, manifold
        );
    }
    
    // ... å…¶ä»–ç¢°æ’ç±»å‹
    return false;
}
```

---

### æ–¹æ¡ˆ 3ï¼šå¢å¼ºæ•°å€¼ç¨³å®šæ€§

#### æ·»åŠ å®¹å·®å¸¸é‡

```cpp
namespace MathUtils {
    constexpr float EPSILON = 1e-6f;
    constexpr float COLLISION_EPSILON = 1e-4f;  // ç¢°æ’æ£€æµ‹ä¸“ç”¨
    constexpr float PENETRATION_SLOP = 0.01f;   // å…è®¸çš„è½»å¾®ç©¿é€
}
```

#### æ”¹è¿›è·ç¦»æ£€æµ‹

```cpp
// ä¿®æ”¹æ‰€æœ‰ç¢°æ’æ£€æµ‹ä¸­çš„è·ç¦»åˆ¤æ–­
if (distSq > radiusSq + MathUtils::COLLISION_EPSILON) {
    return false;  // æ˜ç¡®ä¸ç›¸äº¤
}

// ç©¿é€æ·±åº¦å¤„ç†
float penetration = radiusSum - dist;
if (penetration < MathUtils::PENETRATION_SLOP) {
    penetration = MathUtils::PENETRATION_SLOP;  // ä¿è¯æœ€å°ç©¿é€æ·±åº¦
}
```

---

### æ–¹æ¡ˆ 4ï¼šæ·»åŠ è°ƒè¯•éªŒè¯ç³»ç»Ÿ

```cpp
class CollisionValidator {
public:
    static bool ValidateManifold(const ContactManifold& manifold, 
                                  const Vector3& posA, const Vector3& posB) {
        // éªŒè¯æ³•çº¿å•ä½åŒ–
        float normalLen = manifold.normal.norm();
        if (std::abs(normalLen - 1.0f) > 0.01f) {
            std::cerr << "Warning: Normal not normalized: " << normalLen << std::endl;
            return false;
        }
        
        // éªŒè¯ç©¿é€æ·±åº¦ä¸ºæ­£
        if (manifold.penetration < -MathUtils::EPSILON) {
            std::cerr << "Warning: Negative penetration: " << manifold.penetration << std::endl;
            return false;
        }
        
        // éªŒè¯æ³•çº¿æ–¹å‘å¤§è‡´æŒ‡å‘B
        Vector3 expectedDir = (posB - posA).normalized();
        if (manifold.normal.dot(expectedDir) < 0.0f) {
            std::cerr << "Warning: Normal pointing wrong direction" << std::endl;
            return false;
        }
        
        return true;
    }
};
```

---

### æ–¹æ¡ˆ 5ï¼šä¼˜åŒ– Broad Phase

#### å½“å‰é—®é¢˜
- ç©ºé—´å“ˆå¸Œå’Œå…«å‰æ ‘å¯èƒ½äº§ç”Ÿè¿‡å¤šæ— æ•ˆç¢°æ’å¯¹
- ç¼ºå°‘ AABB å¿«é€Ÿå‰”é™¤

#### æ·»åŠ  AABB é¢„æ£€æµ‹

```cpp
std::vector<SpatialHashBroadPhase::EntityPair> SpatialHashBroadPhase::DetectPairs(
    const std::unordered_map<ECS::EntityID, AABB>& aabbMap
) {
    std::vector<EntityPair> pairs;
    std::unordered_set<uint64_t> processedPairs;
    
    for (const auto& [cellHash, entities] : m_spatialHash) {
        size_t count = entities.size();
        for (size_t i = 0; i < count; ++i) {
            for (size_t j = i + 1; j < count; ++j) {
                ECS::EntityID entityA = entities[i];
                ECS::EntityID entityB = entities[j];
                
                // AABB å¿«é€Ÿå‰”é™¤
                auto itA = aabbMap.find(entityA);
                auto itB = aabbMap.find(entityB);
                if (itA == aabbMap.end() || itB == aabbMap.end()) continue;
                
                if (!itA->second.Intersects(itB->second)) {
                    continue;  // AABB ä¸ç›¸äº¤ï¼Œè·³è¿‡
                }
                
                uint64_t pairHash = HashPair(entityA, entityB);
                if (processedPairs.insert(pairHash).second) {
                    pairs.push_back({entityA, entityB});
                }
            }
        }
    }
    
    return pairs;
}
```

---

## æµ‹è¯•ä¸éªŒè¯æ–¹æ¡ˆ

### æµ‹è¯•ç”¨ä¾‹ 1ï¼šåŸºæœ¬ç¢°æ’
```cpp
void TestBasicSphereBox() {
    // çƒä½“åœ¨ç›’å­æ­£ä¸Šæ–¹ä¸‹è½
    Vector3 spherePos(0, 2, 0);
    Vector3 boxPos(0, 0, 0);
    float radius = 0.5f;
    Vector3 halfExtents(1, 1, 1);
    
    ContactManifold manifold;
    bool result = CollisionDetector::SphereVsBox(
        spherePos, radius, boxPos, halfExtents, Quaternion::Identity(), manifold
    );
    
    assert(!result);  // åº”è¯¥ä¸ç›¸äº¤
}
```

### æµ‹è¯•ç”¨ä¾‹ 2ï¼šè¾¹ç•Œæƒ…å†µ
```cpp
void TestSpherePenetration() {
    // çƒä½“éƒ¨åˆ†ç©¿å…¥ç›’å­
    Vector3 spherePos(0, 1.2f, 0);  // ç›’å­é¡¶éƒ¨ y=1ï¼ŒçƒåŠå¾„ 0.5
    Vector3 boxPos(0, 0, 0);
    
    ContactManifold manifold;
    bool result = CollisionDetector::SphereVsBox(
        spherePos, 0.5f, boxPos, Vector3(1, 1, 1), Quaternion::Identity(), manifold
    );
    
    assert(result);
    assert(manifold.penetration > 0.0f);
    assert(manifold.normal.y() > 0.9f);  // æ³•çº¿åº”è¯¥å‘ä¸Š
}
```

### æµ‹è¯•ç”¨ä¾‹ 3ï¼šå®Œå…¨ç©¿é€
```cpp
void TestSphereInside() {
    // çƒå¿ƒåœ¨ç›’å­å†…éƒ¨
    Vector3 spherePos(0, 0, 0);
    Vector3 boxPos(0, 0, 0);
    
    ContactManifold manifold;
    bool result = CollisionDetector::SphereVsBox(
        spherePos, 0.5f, boxPos, Vector3(1, 1, 1), Quaternion::Identity(), manifold
    );
    
    assert(result);
    assert(manifold.penetration > 1.0f);  // åº”è¯¥æœ‰æ˜æ˜¾ç©¿é€
    CollisionValidator::ValidateManifold(manifold, spherePos, boxPos);
}
```

---

## æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 1. **å†…å­˜æ± ç®¡ç†**
```cpp
class ContactManifoldPool {
    std::vector<ContactManifold> m_pool;
    size_t m_nextFree = 0;
    
public:
    ContactManifold* Acquire() {
        if (m_nextFree >= m_pool.size()) {
            m_pool.emplace_back();
        }
        return &m_pool[m_nextFree++];
    }
    
    void Reset() { m_nextFree = 0; }
};
```

### 2. **SIMD ä¼˜åŒ–å‘é‡è¿ç®—**
```cpp
// ä½¿ç”¨ Eigen çš„å‘é‡åŒ–æ“ä½œ
Vector3 delta = (centerB - centerA).eval();  // å¼ºåˆ¶æ±‚å€¼
float distSq = delta.squaredNorm();  // å·²ä¼˜åŒ–
```

### 3. **æ—©æœŸé€€å‡ºä¼˜åŒ–**
```cpp
// åœ¨ Broad Phase åç«‹å³è¿›è¡Œç²—ç•¥è·ç¦»æ£€æµ‹
float maxDist = radiusA + radiusB + maxVelocity * dt;
if ((centerB - centerA).squaredNorm() > maxDist * maxDist) {
    return false;
}
```

---

## å®æ–½ä¼˜å…ˆçº§

### ğŸ”´ é«˜ä¼˜å…ˆçº§ï¼ˆç«‹å³ä¿®å¤ï¼‰
1. ä¿®å¤ `SphereVsBox` çƒå¿ƒåœ¨ç›’å†…çš„æƒ…å†µ
2. ç»Ÿä¸€æ³•çº¿æ–¹å‘çº¦å®š
3. æ·»åŠ åŸºæœ¬éªŒè¯å‡½æ•°

### ğŸŸ¡ ä¸­ä¼˜å…ˆçº§ï¼ˆçŸ­æœŸä¼˜åŒ–ï¼‰
4. å¢å¼ºæ•°å€¼ç¨³å®šæ€§
5. æ·»åŠ  AABB é¢„æ£€æµ‹
6. å®Œå–„æµ‹è¯•ç”¨ä¾‹

### ğŸŸ¢ ä½ä¼˜å…ˆçº§ï¼ˆé•¿æœŸæ”¹è¿›ï¼‰
7. æ€§èƒ½ä¼˜åŒ–ï¼ˆå†…å­˜æ± ã€SIMDï¼‰
8. æ‰©å±• GJK/EPA é²æ£’æ€§
9. æ·»åŠ è¯¦ç»†æ—¥å¿—ç³»ç»Ÿ

---

## è°ƒè¯•å»ºè®®

### å¯ç”¨å¯è§†åŒ–è°ƒè¯•
```cpp
#ifdef DEBUG_COLLISION
void DebugDrawContact(const ContactManifold& manifold) {
    for (const auto& contact : manifold.contacts) {
        // ç»˜åˆ¶æ¥è§¦ç‚¹ï¼ˆçº¢è‰²çƒä½“ï¼‰
        DrawSphere(contact.point, 0.05f, Color::Red);
        
        // ç»˜åˆ¶æ³•çº¿ï¼ˆç»¿è‰²ç®­å¤´ï¼‰
        DrawArrow(contact.point, contact.point + manifold.normal * 0.5f, Color::Green);
        
        // ç»˜åˆ¶ç©¿é€æ·±åº¦ï¼ˆé»„è‰²çº¿ï¼‰
        DrawLine(contact.point, contact.point - manifold.normal * manifold.penetration, Color::Yellow);
    }
}
#endif
```

### æ·»åŠ æ–­è¨€æ£€æŸ¥
```cpp
#define COLLISION_ASSERT(condition, message) \
    do { \
        if (!(condition)) { \
            std::cerr << "Collision assertion failed: " << message << std::endl; \
            std::cerr << "  File: " << __FILE__ << ", Line: " << __LINE__ << std::endl; \
        } \
    } while(0)
```

---

## æ€»ç»“

é€šè¿‡ä»¥ä¸Šæ–¹æ¡ˆçš„å®æ–½ï¼Œä½ çš„ç¢°æ’æ£€æµ‹ç³»ç»Ÿå°†å®ç°ï¼š

âœ… **å‡†ç¡®æ€§**ï¼šä¿®å¤è¾¹ç•Œæƒ…å†µï¼Œç»Ÿä¸€æ³•çº¿çº¦å®š  
âœ… **ç¨³å®šæ€§**ï¼šå¢å¼ºæ•°å€¼å®¹å·®ï¼Œæ·»åŠ éªŒè¯æœºåˆ¶  
âœ… **é²æ£’æ€§**ï¼šå®Œå–„é”™è¯¯å¤„ç†ï¼Œæ·»åŠ è°ƒè¯•å·¥å…·  
âœ… **æ€§èƒ½**ï¼šä¼˜åŒ– Broad Phaseï¼Œå‡å°‘æ— æ•ˆæ£€æµ‹  
âœ… **å¯ç»´æŠ¤æ€§**ï¼šæ¸…æ™°çš„ä»£ç ç»“æ„ï¼Œå®Œå–„çš„æµ‹è¯•ç”¨ä¾‹

å»ºè®®æŒ‰ç…§ä¼˜å…ˆçº§é€æ­¥å®æ–½ï¼Œæ¯ä¸ªé˜¶æ®µéƒ½è¿›è¡Œå……åˆ†æµ‹è¯•éªŒè¯ã€‚